<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OS-persistently | BLOG</title><meta name="author" content="guesscyj"><meta name="copyright" content="guesscyj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="持久性操作系统-持久性(persistently)章节persist I&#x2F;O设备 关键问题:如何将I&#x2F;O集成进计算机系统中 I&#x2F;O应该如何集成进系统中？其中的一般机制是什么？如何让它们变得高效？  系统架构一个典型系统的架构。其中，CPU通过某种内存总线(memory bus)或或互连电缆连接到系统内存。图像或者其他高性能 I&#x2F;O 设备通过常规的I&amp;#x2F">
<meta property="og:type" content="article">
<meta property="og:title" content="OS-persistently">
<meta property="og:url" content="http://example.com/2023/08/08/OS-persistently/index.html">
<meta property="og:site_name" content="BLOG">
<meta property="og:description" content="持久性操作系统-持久性(persistently)章节persist I&#x2F;O设备 关键问题:如何将I&#x2F;O集成进计算机系统中 I&#x2F;O应该如何集成进系统中？其中的一般机制是什么？如何让它们变得高效？  系统架构一个典型系统的架构。其中，CPU通过某种内存总线(memory bus)或或互连电缆连接到系统内存。图像或者其他高性能 I&#x2F;O 设备通过常规的I&amp;#x2F">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-08-08T02:19:53.000Z">
<meta property="article:modified_time" content="2023-08-09T10:59:52.909Z">
<meta property="article:author" content="guesscyj">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/08/08/OS-persistently/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS-persistently',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-09 18:59:52'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="BLOG"><span class="site-name">BLOG</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OS-persistently</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-08T02:19:53.000Z" title="发表于 2023-08-08 10:19:53">2023-08-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-09T10:59:52.909Z" title="更新于 2023-08-09 18:59:52">2023-08-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OS-persistently"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h1><p>操作系统-持久性(persistently)章节persist</p>
<h2 id="I-x2F-O设备"><a href="#I-x2F-O设备" class="headerlink" title="I&#x2F;O设备"></a>I&#x2F;O设备</h2><blockquote>
<p><strong>关键问题:如何将I&#x2F;O集成进计算机系统中</strong></p>
<p>I&#x2F;O应该如何集成进系统中？其中的一般机制是什么？如何让它们变得高效？</p>
</blockquote>
<h3 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h3><p>一个典型系统的架构。其中，CPU通过某种内存总线(memory bus)或或互连电缆连接到系统内存。图像或者其他高性能 I&#x2F;O 设备通过常规的I&#x2F;O 总线（I&#x2F;O bus）连接到系统，在许多现代系统中会是 PCI 或它的衍生形式。最后，更下面是外围总线（peripheral bus），比如 SCSI、SATA 或者 USB。它们将最慢的设备连接到系统，包括磁盘、鼠标及其他类似设备。</p>
<p><img src="https://s2.loli.net/2023/08/08/NspL24BmOd1RKFa.png" alt="OS-persist-system.png"></p>
<p>分层的设计可以让高性能设备离CPU更近，低性能的设备离CPU远一些。将磁盘和其他低速设备连到外围总线的好处很多，其中较为突出的好处就是你可以在外围总线上连接大量的设备。</p>
<h3 id="标准设备"><a href="#标准设备" class="headerlink" title="标准设备"></a>标准设备</h3><p><img src="https://s2.loli.net/2023/08/08/2HpVzBRMQlmerA3.png" alt="OS-persist-equipment.png"></p>
<p>一个标准设备通常包含两个部分。</p>
<ol>
<li>硬件接口。面向系统其他部分，让系统软件来控制进行操作。拥有自己特定的接口以及交互协议。</li>
<li>内部结构。设备相关的特定实现，负责具体实现设备的接口。</li>
</ol>
<h3 id="标准协议"><a href="#标准协议" class="headerlink" title="标准协议"></a>标准协议</h3><p>上图中，一个设备接口包含3个寄存器:状态(status)寄存器:读取并查看设备的当前状态，命令寄存器(command):通知设备执行某个任务以及数据(data)寄存器:将数据传给设备或接受数据。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(STATUS == BUSY)</span><br><span class="line">    ;	<span class="comment">//wait until device is not busy</span></span><br><span class="line">Write data to DATA <span class="keyword">register</span></span><br><span class="line">Write command to COMMAND <span class="title function_">register</span></span><br><span class="line">    <span class="params">(Doing so starts the device and executes the command)</span></span><br><span class="line"><span class="title function_">While</span><span class="params">(STATUS == BUSY)</span></span><br><span class="line">    ;	<span class="comment">//wait until device is done with your request</span></span><br></pre></td></tr></table></figure>

<ol>
<li><strong>轮询(polling)设备</strong>:操作系统反复读取状态寄存器，等待设备进入可以接收命令的就像状态。</li>
<li>操作系统下发数据到数据寄存器。</li>
<li>操作系统将命令写入命令寄存器。设备就开始执行命令</li>
<li>操作系统停止轮询设备，等待并判断设备是否执行完成命令。</li>
</ol>
<p><strong>优点：</strong>简单且有效。</p>
<p><strong>缺点：</strong>轮询过程低效，在等待设备执行完成命令是浪费大量CPU时间。</p>
<blockquote>
<p>操作系统检查设备状态时如何避免频繁轮询，从而降低管理设备的CPU开销</p>
</blockquote>
<h3 id="利用中断减少CPU开销"><a href="#利用中断减少CPU开销" class="headerlink" title="利用中断减少CPU开销"></a>利用中断减少CPU开销</h3><p><strong>使用中断(interrupt)来减少CPU的开销。</strong></p>
<p>有了中断后,CPU不需要轮询设备，向设备发出请求，然后让对于进程休眠，切换执行其他任务。</p>
<p>当设备完成了自身操作，会抛出一个硬件中断，引起CPU跳转执行操作系统预先定义好的中断服务例程(Interrupt Service Routine,ISR)或更为简单的中断处理程序(interrupt handler)。</p>
<p>中断处理程序是一小段操作系统代码，它会结束之前的请求（比如从设备读取到了数据或者错误码）并且唤醒等待 I&#x2F;O 的进程继续执行。</p>
<p><strong>中断允许计算与 I&#x2F;O 重叠（overlap），这是提高 CPU 利用率的关键</strong></p>
<p>&#x3D;&#x3D;中断并非是最佳方案，例如高性能的设备，反倒会因为中断而是系统变慢,轮询的效果更好&#x3D;&#x3D;</p>
<p>网络中最好不要使用中断,网络段收到大量数据包，如果每一个包都发生一次中断，可能导致活锁(livelock)，不断处理用户层的请求。</p>
<p>基于中断的优化是合并(coalescing)。设备在抛出中断之前往往会等待一小段时间，在次期间，其他请求可能很快完成，因此多次中断可以合并为一次中断抛出，从而降低代价。</p>
<h3 id="利用DMA进行更高效的数据传送"><a href="#利用DMA进行更高效的数据传送" class="headerlink" title="利用DMA进行更高效的数据传送"></a>利用DMA进行更高效的数据传送</h3><blockquote>
<p><strong>如何减少PIO的开销</strong></p>
<p>使用PIO(progtammed I&#x2F;O)，CPU参与了数据的移动，CPU的时间会浪费在向设备传输数据或从设备传出数据的过程中。如何才能分离这项工作，从而提高CPU利用率？</p>
</blockquote>
<p>**DMA(Direct Memory Access)**是一个特殊设备，可以协调完成内存和设备间的数据传递，不需要CPU介入。</p>
<p>DMA工作流程:</p>
<ol>
<li>操作系统通过编程告诉MDA数据在内存的位置，拷贝的大小以及拷贝到哪个设备。操作系统处理其他请求。</li>
<li>DMA任务完成后，DMA控制器会抛出一个中断来告诉操作系统已经完成数据传输。</li>
</ol>
<p><img src="https://s2.loli.net/2023/08/08/yxKlp4FiSfgEWeD.png" alt="OS-persist-DMA.png"></p>
<h3 id="设备交互的方法"><a href="#设备交互的方法" class="headerlink" title="设备交互的方法"></a>设备交互的方法</h3><blockquote>
<p><strong>如何与设备通信</strong></p>
<p>硬件如何与设备通信？是否需要一些明确的指令？或者其他的方式？</p>
</blockquote>
<p>两种通信方式:</p>
<ol>
<li>用明确的I&#x2F;O指令(较老的方式,特权指令)，这些指令规定了操作系统将数据发送到特定设备寄存器的方法</li>
<li>内存映射I&#x2F;O(memory-mapped I&#x2F;0)。硬件将设备寄存器作为内存地址提供。当需要访问设备寄存器时，操作系统转载(读取)或存入(写入)到该内存地址，然后硬件会将读写转移到设备上，而不是物理内存。</li>
</ol>
<p>内存映射 I&#x2F;O 的好处是不需要引入新指令来实现设备交互，但两种方法今天都在使用</p>
<h3 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h3><p>如何将每个设备具体的接口纳入操作系统，且希望操作系统通用。</p>
<p>如文件系统，我们希望开发一个文件系统可以工作在SCSI 硬盘、IDE 硬盘、USB 钥匙串设备等设备之上，并且希望这个文件系统不那么清楚对这些不同设备发出读写请求的全部细节</p>
<blockquote>
<p><strong>如何实现一个设备无关的操作系统</strong></p>
<p>如何保存操作系统的大部分与设备无关，从而对操作系统的主要子系统隐藏设备交互的细节？</p>
</blockquote>
<p>在最底层，操作系统的一部分软件清楚地知道设备如何工作，这部分软件是<strong>设备驱动程序(device driver)</strong></p>
<p><img src="https://s2.loli.net/2023/08/08/Oiu2NdbYF3eklUo.png" alt="OS-persist-deviceDriver.png"></p>
<p>这种封装不足的地方是：一个设备提供了很多特殊的功能，单为了兼容大多数操作系统，不得不提供通用的接口，使得自身的特殊功能无法使用。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>本章介绍了中断和DMA用于提高设备效率。访问设备寄存器的两种方式:I&#x2F;O指令和内存映射I&#x2F;O</p>
<h2 id="磁盘驱动器"><a href="#磁盘驱动器" class="headerlink" title="磁盘驱动器"></a>磁盘驱动器</h2><p>磁盘驱动器(hard disk drive):磁盘驱动器一直是计算机系统重持久数据存储的主要形式，文件系统技术的大部分发展都是基于它们的行为。</p>
<blockquote>
<p><strong>如何存储和访问磁盘上的数据</strong></p>
<p>现代磁盘驱动器如何存储数据？接口是什么？数据是如何安排和访问的？磁盘调度如何提高性能？</p>
</blockquote>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>磁盘驱动器有大量扇区(512字节块)组成，每个扇区都可以读取或写入，在具有n给扇区的磁盘上，从0到n-1编号，可以将磁盘视为一组扇区，0 到 <em>n</em>−1 是驱动器的地址空间（address space）。</p>
<p><strong>多扇区操作是可能的</strong>。实际上，许多文件系统一次读取或写入 4KB（或更多）。但是，在更新磁盘时，驱动器制造商唯一保证的是单个 512 字节的写入是原子的（atomic，即它将完整地完成或者根本不会完成）。因此，如果发生不合时宜的掉电，则只能完成较大写入的一部分 [有时称为不完整写入（torn write）]。</p>
<h3 id="基本几何形状"><a href="#基本几何形状" class="headerlink" title="基本几何形状"></a>基本几何形状</h3><p>现代磁盘的组成：</p>
<p>盘片(platter)是个圆形坚硬的表面，通过引入磁性变化来永久存储数据。磁盘可能有一个或多个盘片。每个盘片有两面，每面都称为表面。这些盘片通常由一些硬质材料（如铝）制成，然后涂上薄薄的磁性层，即使驱动器断电，驱动器也能持久存储数据位。</p>
<p>所有盘片都围绕主轴（spindle）连接在一起，主轴连接到一个电机，以一个恒定（固定）的速度旋转盘片（当驱动器接通电源时）。旋转速率通常以每分钟转数（Rotations Per Minute，RPM）来测量，典型的现代数值在 7200～15000 RPM 范围内。请注意，我们经常会对单次旋转的时间感兴趣，例如，以 10000 RPM 旋转的驱动器意味着一次旋转需要大约 6ms。</p>
<p>数据在扇区的同心圆中的每个表面上被编码。我们称这样的同心圆为一个磁道（track）。一个表面包含数以千计的磁道，紧密地排在一起，数百个磁道只有头发的宽度。</p>
<p>要从表面进行读写操作，我们需要一种机制，使我们能够感应（即读取）磁盘上的磁性图案，或者让它们发生变化（即写入）。读写过程由磁头（disk head）完成；驱动器的每个表面有一个这样的磁头。磁头连接到单个磁盘臂（disk arm）上，磁盘臂在表面上移动，将磁头定位在期望的磁道上。</p>
<h3 id="简单的磁盘驱动器"><a href="#简单的磁盘驱动器" class="headerlink" title="简单的磁盘驱动器"></a>简单的磁盘驱动器</h3><p><img src="https://s2.loli.net/2023/08/08/ygDNJPWXv8e4dZa.png" alt="OS-persist-platter.png"></p>
<p>该磁道只有12个扇区，每个扇区大小为512字节。</p>
<p>磁盘臂末端的磁头位于扇区部分6的上方，磁盘表明逆时针旋转</p>
<p><strong>单磁道延迟：旋转延迟（rotational delay)</strong></p>
<p>假设要读取块0的请求：等待扇区旋转到磁头下。</p>
<p><img src="https://s2.loli.net/2023/08/08/srbX1R85DlFz3Hm.png" alt="OS-persist-multiPlatter.png"></p>
<p><strong>多磁道：寻道时间</strong></p>
<p>为了读取请求：驱动器将磁盘臂移动道正确的磁道(寻道,seek)。之后旋转。</p>
<h3 id="廉价冗余磁盘阵列-RAID"><a href="#廉价冗余磁盘阵列-RAID" class="headerlink" title="廉价冗余磁盘阵列(RAID)"></a>廉价冗余磁盘阵列(RAID)</h3><blockquote>
<p><strong>如何得到大型、快速、可靠的磁盘</strong></p>
<p>我们如何构建一个大型、快速和可靠的存储系统？关键技术是什么？不同方法之间的折中是什么？</p>
</blockquote>
<p>廉价冗余磁盘阵列(Redundant Array of Inexpensive Disks,RAID)，这种技术使用多个磁盘一起构造更快、更大、更可靠的磁盘系统。</p>
<p>优点:</p>
<ol>
<li>性能：并行使用多个磁盘大大加快了I&#x2F;O时间</li>
<li>容量：大型数据集需要大型磁盘</li>
<li>可靠性：在多个磁盘上传输数据(无RAID技术)会使数据容易受到单个磁盘丢失的影响。</li>
</ol>
<h2 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h2><p>进程是虚拟化的CPU，地址空间是虚拟化的内存。</p>
<p>持久存储(persistent storage)。永久存储设备，永久存储信息。内存重的内存会在断电时丢失，持久存储设备重数据不变。因此，操作系统必须特别注意这些设备:<strong>用户用它们保存真正关心的数据</strong></p>
<blockquote>
<p>&#x3D;&#x3D;如何管理持久存储设备&#x3D;&#x3D;</p>
<p>操作系统如何管理持久存储设备？API？实现由哪些重要方面？</p>
</blockquote>
<h3 id="文件和目录-1"><a href="#文件和目录-1" class="headerlink" title="文件和目录"></a>文件和目录</h3><p>存储虚拟化的两个关键抽象:</p>
<p>&#x3D;&#x3D;文件(file)&#x3D;&#x3D;和&#x3D;&#x3D;目录(directory)&#x3D;&#x3D;</p>
<p><strong>文件系统</strong>的责任仅仅是将数据永久存储在磁盘上，并确保当再次请求数据时，得到原来放在那里的内容。做到这一点并不像看起来那么简单！</p>
<h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><p>linux上使用strace可查看系统调用 <code>strace rm foo.txt</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo&quot;</span>,O_CREAT|W=O_WRONLY,O_TRUNC);</span><br></pre></td></tr></table></figure>

<p>返回一个文件描述符，是进程私有的。</p>
<h3 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h3><p><strong>相关知识请自行学习 key:文件系统</strong></p>
<p>读写文件描述符</p>
<p>改变文件读写位置(偏移量)：lseek(),改变内核中的值</p>
<p><strong>fsync()立即写入：</strong>文件系统通过强制将所有脏数据写入磁盘来响应。</p>
<h3 id="文件重命名"><a href="#文件重命名" class="headerlink" title="文件重命名"></a>文件重命名</h3><p>系统调用rename(char* old,char* new)是原子(atomic)调用，不论系统是否崩溃。如果崩溃，不会是中间状态，只会是就名称或新名称。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;foo.txt.tmp&quot;</span>, O_WRONLY|O_CREAT|O_TRUNC); </span><br><span class="line">write(fd, buffer, size); <span class="comment">// write out new version of file </span></span><br><span class="line">fsync(fd); </span><br><span class="line">close(fd); </span><br><span class="line">rename(<span class="string">&quot;foo.txt.tmp&quot;</span>, <span class="string">&quot;foo.txt&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>编译器做的事:</p>
<ol>
<li>将文件的新版本写入临时名称(foot.txt.tmp)，使用fsync()将器强制写入磁盘</li>
<li>当应用程序确定新文件的元数据和内容在磁盘上，将临时文件重命名为原有文件的名称。</li>
<li>最后一步自动将新文件交换到位，同时删除旧版本的文件，从而实现原子文件更新。</li>
</ol>
<h3 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h3><p>文件元数据(metadata)</p>
<p>stat()&#x2F;fstat()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span> </span><br><span class="line"> <span class="type">dev_t</span> st_dev; <span class="comment">/* ID of device containing file */</span> </span><br><span class="line"> <span class="type">ino_t</span> st_ino; <span class="comment">/* inode number */</span> </span><br><span class="line"> <span class="type">mode_t</span> st_mode; <span class="comment">/* protection */</span> </span><br><span class="line"> <span class="type">nlink_t</span> st_nlink; <span class="comment">/* number of hard links */</span> </span><br><span class="line"> <span class="type">uid_t</span> st_uid; <span class="comment">/* user ID of owner */</span> </span><br><span class="line"> <span class="type">gid_t</span> st_gid; <span class="comment">/* group ID of owner */</span> </span><br><span class="line"> <span class="type">dev_t</span> st_rdev; <span class="comment">/* device ID (if special file) */</span> </span><br><span class="line"> <span class="type">off_t</span> st_size; <span class="comment">/* total size, in bytes */</span> </span><br><span class="line"> <span class="type">blksize_t</span> st_blksize; <span class="comment">/* blocksize for filesystem I/O */</span> </span><br><span class="line"> <span class="type">blkcnt_t</span> st_blocks; <span class="comment">/* number of blocks allocated */</span> </span><br><span class="line"> <span class="type">time_t</span> st_atime; <span class="comment">/* time of last access */</span> </span><br><span class="line"> <span class="type">time_t</span> st_mtime; <span class="comment">/* time of last modification */</span> </span><br><span class="line"> <span class="type">time_t</span> st_ctime; <span class="comment">/* time of last status change */</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>unlink()只需要待删除文件的名称，<strong>为什么不是remove或delete?</strong></p>
<h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><p>目录的格式被视为文件系统元数据，所以只能间接更新目录，而不能直接写入目录。</p>
<p>创建目录用系统调用mkdir()。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">prompt&gt; strace mkdir foo </span><br><span class="line">... </span><br><span class="line">mkdir(<span class="string">&quot;foo&quot;</span>, <span class="number">0777</span>) = <span class="number">0</span> </span><br><span class="line">... </span><br><span class="line">prompt&gt;</span><br></pre></td></tr></table></figure>

<p>创建的目录是”空的”，包含最少的内容，有.和..目录</p>
<h3 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h3><p>函数调用opendir()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span> </span><br><span class="line">	<span class="type">char</span> d_name[<span class="number">256</span>]; <span class="comment">/* filename */</span></span><br><span class="line">	<span class="type">ino_t</span> d_ino; <span class="comment">/* inode number */</span> </span><br><span class="line">	<span class="type">off_t</span> d_off; <span class="comment">/* offset to the next dirent */</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">short</span> d_reclen; <span class="comment">/* length of this record */</span> </span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> d_type; <span class="comment">/* type of file */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h3><p>rmdir()，只能删除空目录</p>
<h3 id="硬链接"><a href="#硬链接" class="headerlink" title="硬链接"></a>硬链接</h3><p>为什么删除文件是unlink()</p>
<p>文件系统树种创建条目的新方法:link()，接收一个旧路径名和一个新路径名</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash"><span class="built_in">ln</span>创建文件的硬链接</span></span><br><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">echo</span> hello &gt; file</span> </span><br><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">cat</span> file</span> </span><br><span class="line">hello </span><br><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">ln</span> file file2</span> </span><br><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">cat</span> file2</span> </span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p>对要链接的目录创建了另一个名称，并将器执行原有文件相同的inode号。不以任何方式复制</p>
<p>创建文件的过程:</p>
<ol>
<li>构建一个结构(inode)，跟踪文件的所有信息</li>
<li>将人可读的名称链接到该文件，并将链接放入目录</li>
</ol>
<h3 id="符号链接-软链接"><a href="#符号链接-软链接" class="headerlink" title="符号链接(软链接)"></a>符号链接(软链接)</h3><p>符号链接(symbolic link)，也称软链接(soft link)</p>
<p><strong>硬链接的局限:</strong></p>
<ul>
<li>不能创建目录的硬链接，否则可能出现环</li>
<li>不能硬链接到其他磁盘分区中的文件(inode号在特定文件系统中是唯一的，而不是跨文件系统)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="built_in">ln</span> -s</span></span><br><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">echo</span> hello &gt; file</span> </span><br><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">ln</span> -s file file2</span> </span><br><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">cat</span> file2</span> </span><br><span class="line">hello</span><br></pre></td></tr></table></figure>

<p><strong>区别:</strong></p>
<ul>
<li>符号链接本身实际上是一个不同类型的文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">stat</span> file</span> </span><br><span class="line"> ... regular file ... </span><br><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">stat</span> file2</span> </span><br><span class="line"> ... symbolic link ...</span><br><span class="line"><span class="meta prompt_"> # </span><span class="language-bash"><span class="built_in">ls</span></span></span><br><span class="line"><span class="meta prompt_">prompt&gt; </span><span class="language-bash"><span class="built_in">ls</span> -al</span> </span><br><span class="line">drwxr-x--- 2 remzi remzi 29 May 3 19:10 ./ </span><br><span class="line">drwxr-x--- 27 remzi remzi 4096 May 3 15:14 ../ </span><br><span class="line">-rw-r----- 1 remzi remzi 6 May 3 19:10 file </span><br><span class="line">lrwxrwxrwx 1 remzi remzi 4 May 3 19:10 file2 -&gt; file</span><br></pre></td></tr></table></figure>

<p>长格式的第一个字符:常规文件是’-‘,目录是’d’,软连接是’l’</p>
<p>软连接类型的文件大小取决于链接到的文件的路径名。当然，可能有<strong>悬空引用</strong>(dangling reference)</p>
<h2 id="文件系统实现"><a href="#文件系统实现" class="headerlink" title="文件系统实现"></a>文件系统实现</h2><p>VSFS(Very Simple File System,简单文件系统)</p>
<blockquote>
<p><strong>如何实现简单的文件系统</strong></p>
<p>如何构建一个简单的文件系统？磁盘上需要什么结构？它们需要记录什么？它们如何访问？</p>
</blockquote>
<h3 id="思考方式"><a href="#思考方式" class="headerlink" title="思考方式"></a>思考方式</h3><p>两个方面：</p>
<ol>
<li>文件系统的数据结构(data structure):使用哪些类型的结构来组织其数据和元数据</li>
<li>访问方式(access method):如何将进程发出的调用，如open()，映射到它的结构上?在执行特定系统调用期间读取哪些结构？改写哪些结构？所有这些步骤的执行效率如何？</li>
</ol>
<h3 id="整体组织"><a href="#整体组织" class="headerlink" title="整体组织"></a>整体组织</h3><p>将磁盘分成块(block)，简单的文件系统只使用一种块大小。通常是4KB假设我们磁盘只有64块，地址从0~63</p>
<p>这些块存储什么？</p>
<ol>
<li>用户数据:D</li>
<li>元数据(inode table，inode表):i</li>
<li>分配结构(记录inode或数据库是空闲还是已分配):i&amp;&amp;d</li>
<li>超级块(superblock包含特定文件系统的信息，多少个inode和数据块): S</li>
</ol>
<h3 id="文件组织-inode"><a href="#文件组织-inode" class="headerlink" title="文件组织:inode"></a>文件组织:inode</h3><p>inode(index node,索引节点)</p>
<p>通过inode来找到磁盘上的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">blk = (inumber * <span class="keyword">sizeof</span>(<span class="type">inode_t</span>))/blockSize;</span><br><span class="line">sector = ((blk * blockSize)+indoeStartAddr)/secotrSize</span><br></pre></td></tr></table></figure>

<p>每个inode中保存了所有关于文件的信息:文件类型、大小、分配的块数、保护信息、时间等。此类信息称为元数据(metadata)</p>
<p><strong>inode中最重要的就是如何引用数据块的位置</strong>:在inode中有一个或多个直接指针(磁盘地址)。每个指针指向属于该文件的一个磁盘块。如果文件非常大(大于块的大小乘以直接指针数)</p>
<p><strong>多级索引</strong></p>
<p>为了支持更大的文件，可引入间接指针(indirect pointer)的特殊指针。不是指向保护用户数据的块，而是指向包含更多指针的块，每个指针指向用户数据。inode 可以有一些固定数量（例如 12 个）的直接指针和一个间接指针。如果文件变得足够大，则会分配一个间接块（来自磁盘的数据块区域），并将 inode 的间接指针设置为指向它。假设一个块是 4KB，磁盘地址是 4 字节，那就增加了 1024 个指针。文件可以增长到（12 + 1024）×4KB，即 4144KB</p>
<h2 id="局部性和快速文件系统"><a href="#局部性和快速文件系统" class="headerlink" title="局部性和快速文件系统"></a>局部性和快速文件系统</h2><p>&#x2F;&#x2F;两个文件系统请自行观看</p>
<h2 id="崩溃一致性-FSCK和日志"><a href="#崩溃一致性-FSCK和日志" class="headerlink" title="崩溃一致性: FSCK和日志"></a>崩溃一致性: FSCK和日志</h2><p>文件系统管理一组数据结构以实现预期的抽象:文件、目录以及所有其他元数据。是文件系统的基本抽象。</p>
<p><strong>文件系统数据结构必须持久(persist)，即数据必须长期存在，存在在断电也能保留数据的设备上</strong>，如硬盘或基于闪存的SSD</p>
<p>如何在出现断电（power loss）或系统崩溃（system crash）的情况下，更新持久数据结构。</p>
<p>由于断电和崩溃，更新持久性数据结构可能非常棘手，并导致了文件系统实现中一个有趣的新问题，称为<strong>崩溃一致性问题（crash-consistency problem）</strong></p>
<blockquote>
<p><strong>考虑到崩溃，如何更新磁盘</strong></p>
<p>系统可能在任何两次写入之间崩溃或断电，因此磁盘上状态可能仅部分地更新。崩溃后，系统启动并希望再次挂载文件系统。鉴于崩溃可能发生在任意时间点，如何确保文件系统将磁盘上的映射保持在合理的状态。</p>
</blockquote>
<p><strong>文件系统检查程序(file system checker,fsck)</strong></p>
<p><strong>日志记录(journaling,也称预写日志，write-aheadlogging)</strong></p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>我们需要一种工作负载（workload），它以某种方式更新磁盘结构。这里假设工作负载很简单：将单个数据块附加到原有文件。通过打开文件，调用 lseek()将文件偏移量移动到文件末尾，然后在关闭文件之前，向文件发出单个4KB 写入来完成追加。</p>
<p>当用户发出write()系统调用是，这些写操作通常不会立即发生。脏的inode、位图和新数据先在内存(页面缓存，page cache)中存在一段时间。当文件系统最终决定将它们写入磁盘时（比如说 5s或 30s），文件系统将向磁盘发出必要的写入请求。</p>
<p><strong>崩溃场景</strong></p>
<p>只有一次写入成功，可能有以下结果:</p>
<ul>
<li><strong>只将数据块(Db)写入磁盘。</strong>数据在磁盘上，没有指向它的inode，和分配的位图，因此，没有任何问题。</li>
<li><strong>只有更新的inode写入了磁盘。</strong>inode指向磁盘地址，其中Db未写入。如果进行读取，会读取到垃圾数据。且文件系统不一致，inode表示已分配，位图表示未分配，需解决</li>
<li><strong>只有更新后的位图写入了磁盘。</strong>文件系统不一致，将导致空间泄漏，因为文件系统永远不会使用块5</li>
</ul>
<p>2次成功，最后一次失败，可能有以下结果:</p>
<ul>
<li><strong>inode和位图写入了磁盘，但没有写入数据。</strong>从文件系统元数据角度看，一切正常，但块中是垃圾</li>
<li><strong>inode和数据块写入了磁盘，没有写入位图。</strong>inode和位图存在不一致，任需解决</li>
<li><strong>位图和数据块写入了磁盘，没有写入inode。</strong>任存在不一致的问题。不知道指向了哪一个文件</li>
</ul>
<p><strong>崩溃一致性问题</strong></p>
<p>文件系统可能因为崩溃导致:数据结构不一致，空间泄漏，可能将垃圾数据返回给用户等。</p>
<h3 id="解决方案1-文件系统检查程序"><a href="#解决方案1-文件系统检查程序" class="headerlink" title="解决方案1:文件系统检查程序"></a>解决方案1:文件系统检查程序</h3><p>解决方法:让不一致的事情发生，然后再修复它们(重启时)。</p>
<p>Unix下的fsck工具采用这样的方法，查找步一致并修复它们</p>
<p>工具fsck在许多阶段运行，如在文件系统挂载并可以之前运行。一旦完成，磁盘上的文件系统应该是一致的，因此可让用户访问。</p>
<p>fsck的基本总结:</p>
<ul>
<li><strong>超级块：</strong>fsck首先检查超级快是否合理，健全性检查。例如确保文件系统大小大于分配的块数。通常，这些健全性检查的目的是找到一个可疑的（冲突的）超级块。在这种情况下，系统（或管理员）可以决定使用超级块的备用副本。</li>
<li><strong>空闲块：</strong>fsck扫描inode、间接块、双重间接块等，以了解当前在文件系统中分配的块。它利用这些知识生成正确版本的分配位图。因此，如果位图和 inode之间存在任何不一致，则通过信任 inode 内的信息来解决它。对所有 inode 执行相同类型的检查，确保所有看起来像在用的 inode，都在 inode 位图中有标记。</li>
<li><strong>inode状态：</strong>检查每个inode是否存在损坏或其他问题。如，fsck确保每个分配的 inode 具有有效的类型字段（即常规文件、目录、符号链接等）。如果 inode 字段存在问题，不易修复，则 inode 被认为是可疑的，并被 fsck 清除，inode 位图相应地更新。</li>
<li><strong>inode链接：</strong>fsck验证每个已分配的inode的链接数。为了验证链接计数，fsck 从根目录开始扫描整个目录树，并为文件系统中的每个文件和目录构建自己的链接计数。如果新计算的计数与 inode 中找到的计数不匹配，则必须采取纠正措施，通常是修复 inode 中的计数。如果发现已分配的 inode 但没有目录引用它，则会将其移动到 lost + found 目录。</li>
<li><strong>重复：</strong>fsck检查重复指针，即两个不同的inode引用同一个块的情况。如果一个inode明显不好，可能会被清除。或者，可以复制指向的块，从而根据需要为每个inode 提供其自己的副本。</li>
<li><strong>坏块：</strong>在扫描所有指针列表时，还会检查坏块指针。如果指针明显指向超过其有效范围的某个指针，认为是“块的”。如，它的地址指向大于分区大小的块。在这种情况下，fsck 不能做任何太聪明的事情。它只是从 inode 或间接块中删除（清除）该指针。</li>
<li><strong>目录检查：</strong>fsck不了解用户文件的内容。但目录包含有文件系统本身创建的特定格式的信息。因此，fsck对每个目录的内容执行额外的完整性检查，确保“.”和“..”是前面的条目，目录条目中引用的每个 inode 都已分配，并确保整个层次结构中没有目录的引用超过一次。</li>
</ul>
<p><strong>缺点：</strong>性能太低，扫描整个磁盘，修改的问题太少，开销太过昂贵</p>
<h3 id="解决方案2：日志-或预写日志"><a href="#解决方案2：日志-或预写日志" class="headerlink" title="解决方案2：日志(或预写日志)"></a>解决方案2：日志(或预写日志)</h3><p>基本思路：更新磁盘时，在覆写结构之前，首先写下一点小注记，描述要做的事情。注记就是“预写”部分，我们把它写入一个结构，并组织成“日志”</p>
<p>通过将注释写入磁盘，可以保证在更新(覆写)正在更新的结构期间发生崩溃时，能够返回并查看你所做的注记，然后重试。因此，可在崩溃后准确知道要修复的内容，而不必扫描整个磁盘。</p>
<p><strong>增加工作期间的工作量，从而减少恢复期间的工作量。</strong></p>
<p>日志有时存放在单独设备上，或作为文件系统中的文件</p>
<h4 id="数据日志"><a href="#数据日志" class="headerlink" title="数据日志"></a>数据日志</h4><p><img src="https://s2.loli.net/2023/08/09/OcTSU65VCKGjZPQ.png" alt="journOS-persist-journaling-process.png"></p>
<p>写入了5个块。</p>
<ul>
<li>事务开始(TxB)告诉有关此更新的信息，包括多文件系统即将进行的更新的相关信息，以及某种事务标识符(transaction identifier，TID)</li>
<li>中间3个块只包含块本身的确切内容，被称为物理日志(physical logging)</li>
<li>事务结束的标记(TxE),也包含TID</li>
</ul>
<p>一旦这个事务安全地存在于磁盘上，我们就可以覆写文件系统中的旧结构了。这个过程称为<strong>加检查点</strong>（checkpointing）。因此，为了对文件系统加检查点（checkpoint，即让它与日志中即将进行的更新一致），我们将 I[v2]、B[v2]和 Db 写入其磁盘位置，如上所示。如果这些写入成功完成，我们已成功地为文件系统加上了检查点，基本上完成了。因此，我们的初始操作顺序如下。</p>
<ol>
<li><strong>日志写入：</strong>将事务(包括事务开始块，所有即将写入的数据和元数据更新以及事务结束块)写入日志，等待这些写入完成。</li>
<li><strong>加检查点：</strong>将待处理的元数据和数据更新写入文件系统中的最终位置</li>
</ol>
<p>磁盘内部可以执行调度并以任何顺序完成大批写入的小块。因此可以最后写Db，但这样无法保证数据准确。断电可能导致丢失</p>
<blockquote>
<p><strong>强制写入磁盘</strong></p>
<p>为了在两次磁盘写入之间强制执行顺序，现代文件系统采取了一些额外的预防措施。</p>
<p>由于磁盘中写入缓存的使用增加，事情变得有点复杂了。启用写入缓冲后（有时称为立即报告，immediate reporting），如果磁盘已经放入磁盘的内存缓存中、但尚未到达磁盘，磁盘就会通知操作系统写入完成。如果操作系统随后发出后续写入，则无法保证它在先前写入之后到达磁盘。因此，不再保证写入之间的顺序。一种解决方案是禁用写缓冲。然而，更现代的系统采取额外的预防措施，发出明确的写入屏障（write barrier）。这样的屏障，当它完成时，能确保在屏障之前发出的所有写入，先于在屏障之后发出的所有写入到达磁盘。</p>
</blockquote>
<p>如果Db的写入是在超级块上，甚至会导致文件系统无法挂载</p>
<blockquote>
<p>&#x3D;&#x3D;优化日志写入&#x3D;&#x3D;</p>
<p>写入日志的效率特别低。文件系统必须写出事务开始块和事务的内容。只要这些写入完成后，文件系统才能将事务结束块发送到磁盘。</p>
<p>将事务写入日志时，在开始和结束块中<strong>包含日志内容的校验和</strong>。这样做可以使文件系统立即写入整个事务，而不<strong>会产生等待</strong>。如果在恢复期间，文件系统发现<strong>计算的校验和与事务中存储的校验和不匹配</strong>，则可以断定在写入事务期间发生了崩溃，从而丢弃了文件系统更新。因此，通过写入协议和恢复系统中的小调整，文件系统可以实现更快的通用情况性能。最重要的是，系统更可靠了，因为来自日志的任何读取现在都受到校验和的保护。</p>
</blockquote>
<p>事务分两部写入</p>
<p>更新文件系统的过程:</p>
<ol>
<li>**日志写入:**将事务的内容(包括TxB，元数据和数据)写入日志，等待写入完成</li>
<li>**日志提交:**将事务提交块(TxE)写入日志，等待写完成，事务被认为已提交</li>
<li>**加检查点:**将更新内容（元数据和数据）写入其最终的磁盘位置。</li>
</ol>
<h4 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h4><p>如何利用日志从崩溃中恢复(recover)。</p>
<p>在写入日志之前崩溃：跳过待执行的更新</p>
<p>在写入之后但加检测点之前：扫描日志，并查找已提交到磁盘的事务，然后将这些事务重放(replayed),文件系统再次尝试将事务中的块写入最终的磁盘位置。</p>
<h4 id="批处理日志更新"><a href="#批处理日志更新" class="headerlink" title="批处理日志更新"></a>批处理日志更新</h4><p>在更新磁盘上的文件如创建时，会修改很多的结构，如inode，位图。通过日志，我们将这些信息提交给创建的日志。</p>
<p>为了解决这个问题，一些文件系统不会一次一个地向磁盘提交更新。</p>
<p><strong>将所有更新缓冲到全局事务中。将内存中的结构标记为脏。并添加到块列表中，形成当前的事务。最后写入磁盘中。</strong></p>
<h4 id="使日志有效"><a href="#使日志有效" class="headerlink" title="使日志有效"></a>使日志有效</h4><p>日志很小，如果不断向它添加事务，会很快填满，此时会发生什么?</p>
<ol>
<li>日志越大，恢复时间越长</li>
<li>已满或接近满时，不能向磁盘提交进一步的事务，从而使文件系统无用</li>
</ol>
<p><strong>解决方法：</strong>将日志看为循环数据结构，可以一遍又一遍地重复使用,所以日志也较循环日志(circular log)</p>
<p>文件系统必须在加检查点后的某个时间操作，此时相关数据已经写完，文件系统应释放它在日志中占用的空间，允许重用日志空间。</p>
<p>因此基本协议的过程添加了另一个步骤:</p>
<ol>
<li><strong>日志写入</strong></li>
<li><strong>日志提交</strong></li>
<li><strong>加检查点</strong></li>
<li><strong>释放</strong>:通过更新日志超级块，在日志中标记事务为空闲</li>
</ol>
<h2 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h2><p>分布式系统是由多个独立计算机或服务器通过网络连接而组成的系统。在分布式系统中，这些计算机或服务器通过消息传递或共享资源来协同工作，以完成某个共同的任务或提供某种服务。</p>
<blockquote>
<p><strong>如何构造在组件故障时仍能工作的系统</strong></p>
<p>如何用无法一直正常工作的部件，来构建能工作系统？</p>
</blockquote>
<p>故障是分布式系统的核心挑战，也代表这一个机遇。</p>
<p>通过聚集一组机器，我们可以构建一个看起来很少失败的系统，尽管它的组件经常出现故障。</p>
<blockquote>
<p><strong>通信本身是不可靠的</strong></p>
<p>几乎在所有情况下，将通信视为根本不可靠的活动是很好的。位讹误、关闭或无效的链接和机器，以及缺少传入数据包的缓冲区空间，都会导致相同的结果：数据包有时无法到达目的地。为了在这种不可靠的网络上建立可靠的服务，我们必须考虑能够应对数据包丢失的技术。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">guesscyj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/08/OS-persistently/">http://example.com/2023/08/08/OS-persistently/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/08/03/OS-thread/" title="OS-thread"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">OS-thread</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">guesscyj</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.</span> <span class="toc-text">持久性</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-x2F-O%E8%AE%BE%E5%A4%87"><span class="toc-number">1.1.</span> <span class="toc-text">I&#x2F;O设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">系统架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%AE%BE%E5%A4%87"><span class="toc-number">1.1.2.</span> <span class="toc-text">标准设备</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.3.</span> <span class="toc-text">标准协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E4%B8%AD%E6%96%AD%E5%87%8F%E5%B0%91CPU%E5%BC%80%E9%94%80"><span class="toc-number">1.1.4.</span> <span class="toc-text">利用中断减少CPU开销</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8DMA%E8%BF%9B%E8%A1%8C%E6%9B%B4%E9%AB%98%E6%95%88%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BC%A0%E9%80%81"><span class="toc-number">1.1.5.</span> <span class="toc-text">利用DMA进行更高效的数据传送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E4%BA%A4%E4%BA%92%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.6.</span> <span class="toc-text">设备交互的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.1.7.</span> <span class="toc-text">设备驱动程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.1.8.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="toc-number">1.2.</span> <span class="toc-text">磁盘驱动器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.1.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%87%A0%E4%BD%95%E5%BD%A2%E7%8A%B6"><span class="toc-number">1.2.2.</span> <span class="toc-text">基本几何形状</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E7%A3%81%E7%9B%98%E9%A9%B1%E5%8A%A8%E5%99%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">简单的磁盘驱动器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%89%E4%BB%B7%E5%86%97%E4%BD%99%E7%A3%81%E7%9B%98%E9%98%B5%E5%88%97-RAID"><span class="toc-number">1.2.4.</span> <span class="toc-text">廉价冗余磁盘阵列(RAID)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.</span> <span class="toc-text">文件和目录</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95-1"><span class="toc-number">1.3.1.</span> <span class="toc-text">文件和目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.2.</span> <span class="toc-text">创建文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.3.</span> <span class="toc-text">读写文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E9%87%8D%E5%91%BD%E5%90%8D"><span class="toc-number">1.3.4.</span> <span class="toc-text">文件重命名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF"><span class="toc-number">1.3.5.</span> <span class="toc-text">获取文件信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">1.3.6.</span> <span class="toc-text">删除文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.7.</span> <span class="toc-text">创建目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.8.</span> <span class="toc-text">读取目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%9B%AE%E5%BD%95"><span class="toc-number">1.3.9.</span> <span class="toc-text">删除目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E9%93%BE%E6%8E%A5"><span class="toc-number">1.3.10.</span> <span class="toc-text">硬链接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E9%93%BE%E6%8E%A5-%E8%BD%AF%E9%93%BE%E6%8E%A5"><span class="toc-number">1.3.11.</span> <span class="toc-text">符号链接(软链接)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">文件系统实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E6%96%B9%E5%BC%8F"><span class="toc-number">1.4.1.</span> <span class="toc-text">思考方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E7%BB%84%E7%BB%87"><span class="toc-number">1.4.2.</span> <span class="toc-text">整体组织</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%BB%84%E7%BB%87-inode"><span class="toc-number">1.4.3.</span> <span class="toc-text">文件组织:inode</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%92%8C%E5%BF%AB%E9%80%9F%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">局部性和快速文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B4%A9%E6%BA%83%E4%B8%80%E8%87%B4%E6%80%A7-FSCK%E5%92%8C%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.</span> <span class="toc-text">崩溃一致性: FSCK和日志</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">1.6.1.</span> <span class="toc-text">一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%A3%80%E6%9F%A5%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.6.2.</span> <span class="toc-text">解决方案1:文件系统检查程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882%EF%BC%9A%E6%97%A5%E5%BF%97-%E6%88%96%E9%A2%84%E5%86%99%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.3.</span> <span class="toc-text">解决方案2：日志(或预写日志)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%97%A5%E5%BF%97"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">数据日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">恢复</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E5%A4%84%E7%90%86%E6%97%A5%E5%BF%97%E6%9B%B4%E6%96%B0"><span class="toc-number">1.6.3.3.</span> <span class="toc-text">批处理日志更新</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E6%97%A5%E5%BF%97%E6%9C%89%E6%95%88"><span class="toc-number">1.6.3.4.</span> <span class="toc-text">使日志有效</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.7.</span> <span class="toc-text">分布式系统</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/OS-persistently/" title="OS-persistently">OS-persistently</a><time datetime="2023-08-08T02:19:53.000Z" title="发表于 2023-08-08 10:19:53">2023-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/03/OS-thread/" title="OS-thread">OS-thread</a><time datetime="2023-08-03T11:26:02.000Z" title="发表于 2023-08-03 19:26:02">2023-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/25/stm32-study/" title="stm32-study">stm32-study</a><time datetime="2023-07-25T10:44:02.000Z" title="发表于 2023-07-25 18:44:02">2023-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/18/OSBlog/" title="OSBlog">OSBlog</a><time datetime="2023-07-18T07:57:45.000Z" title="发表于 2023-07-18 15:57:45">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/14/OS/" title="OS">OS</a><time datetime="2023-07-14T07:26:36.000Z" title="发表于 2023-07-14 15:26:36">2023-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By guesscyj</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OS-thread | BLOG</title><meta name="author" content="guesscyj"><meta name="copyright" content="guesscyj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="并发并发:介绍线程(thread) 经典观点是一个程序只有一个执行点(一个程序计数器，用来存放要执行的指令)，但多线程(multi-threaded)程序会有多个执行点(多个程序计数器，每个都用于取指令和执行)。共享地址空间，从而能够访问相同的数据 每个线程拥有自己的寄存器，一如果两个线程运行在一个处理器上，从运行一个线程(T1)切换到另一个线程(T2)，必定发生上下文切换(context swi">
<meta property="og:type" content="article">
<meta property="og:title" content="OS-thread">
<meta property="og:url" content="http://example.com/2023/08/03/OS-thread/index.html">
<meta property="og:site_name" content="BLOG">
<meta property="og:description" content="并发并发:介绍线程(thread) 经典观点是一个程序只有一个执行点(一个程序计数器，用来存放要执行的指令)，但多线程(multi-threaded)程序会有多个执行点(多个程序计数器，每个都用于取指令和执行)。共享地址空间，从而能够访问相同的数据 每个线程拥有自己的寄存器，一如果两个线程运行在一个处理器上，从运行一个线程(T1)切换到另一个线程(T2)，必定发生上下文切换(context swi">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-08-03T11:26:02.000Z">
<meta property="article:modified_time" content="2023-08-08T02:17:43.275Z">
<meta property="article:author" content="guesscyj">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/08/03/OS-thread/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS-thread',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-08 10:17:43'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="BLOG"><span class="site-name">BLOG</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OS-thread</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-08-03T11:26:02.000Z" title="发表于 2023-08-03 19:26:02">2023-08-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-08T02:17:43.275Z" title="更新于 2023-08-08 10:17:43">2023-08-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OS-thread"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><h2 id="并发-介绍"><a href="#并发-介绍" class="headerlink" title="并发:介绍"></a>并发:介绍</h2><p><strong>线程(thread)</strong></p>
<p>经典观点是一个程序只有一个执行点(一个程序计数器，用来存放要执行的指令)，但多线程(multi-threaded)程序会有多个执行点(多个程序计数器，每个都用于取指令和执行)。<strong>共享地址空间，从而能够访问相同的数据</strong></p>
<p>每个线程拥有自己的寄存器，一如果两个线程运行在一个处理器上，从运行一个线程(T1)切换到另一个线程(T2)，必定发生上下文切换(context switch)。</p>
<p>线程切换，将状态保存到进程控制块(Process Control Block,PCB)。多个线程控制块(Thread Control Block，TCB)。保存每个线程的状态。<strong>两者之间的区别在于线程的地址空间保存不变（不需要切换当前使用的页表)</strong></p>
<p>拥有多线程的进程，有两个线程，地址空间不同。</p>
<p>所有位于栈上的变量、参数、返回值和其他放在栈上的东西，将被放置在有时称为线程本地（thread-local）存储的地方，即相关线程的栈。</p>
<h3 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, (<span class="type">char</span> *) arg); </span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line"><span class="type">pthread_t</span> p1, p2; </span><br><span class="line"><span class="type">int</span> rc; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: begin\n&quot;</span>); </span><br><span class="line">rc = pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">&quot;A&quot;</span>); assert(rc == <span class="number">0</span>); </span><br><span class="line">rc = pthread_create(&amp;p2, <span class="literal">NULL</span>, mythread, <span class="string">&quot;B&quot;</span>); assert(rc == <span class="number">0</span>); </span><br><span class="line"><span class="comment">// join waits for the threads to finish </span></span><br><span class="line">rc = pthread_join(p1, <span class="literal">NULL</span>); assert(rc == <span class="number">0</span>); </span><br><span class="line">rc = pthread_join(p2, <span class="literal">NULL</span>); assert(rc == <span class="number">0</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: end\n&quot;</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定一系列指令，有很多可能执行的顺序，取决于调度程序。</p>
<p><strong>线程创建有点像进行函数调用。然而，并不是首先执行函数然后返回给调用者，而是为被调用的例程创建一个新的执行线程，它可以独立于调用者运行，可能在从创建者返回之前运行，但也许会晚得多。</strong></p>
<h3 id="共享数据带来的麻烦"><a href="#共享数据带来的麻烦" class="headerlink" title="共享数据带来的麻烦"></a>共享数据带来的麻烦</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mythreads.h&quot;</span> </span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>; </span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// mythread() </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Simply adds 1 to counter repeatedly, in a loop </span></span><br><span class="line"><span class="comment">// No, this is not how you would add 10,000,000 to </span></span><br><span class="line"><span class="comment">// a counter, but it shows the problem nicely. </span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mythread</span><span class="params">(<span class="type">void</span> *arg)</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: begin\n&quot;</span>, (<span class="type">char</span> *) arg); </span><br><span class="line"><span class="type">int</span> i; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1e7</span>; i++) &#123; </span><br><span class="line">counter = counter + <span class="number">1</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s: done\n&quot;</span>, (<span class="type">char</span> *) arg); </span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// main() </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="comment">// Just launches two threads (pthread_create) </span></span><br><span class="line"><span class="comment">// and then waits for them (pthread_join) </span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span><br><span class="line">&#123; </span><br><span class="line"><span class="type">pthread_t</span> p1, p2; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: begin (counter = %d)\n&quot;</span>, counter); </span><br><span class="line">Pthread_create(&amp;p1, <span class="literal">NULL</span>, mythread, <span class="string">&quot;A&quot;</span>); </span><br><span class="line">Pthread_create(&amp;p2, <span class="literal">NULL</span>, mythread, <span class="string">&quot;B&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// join waits for the threads to finish </span></span><br><span class="line">Pthread_join(p1, <span class="literal">NULL</span>); </span><br><span class="line">Pthread_join(p2, <span class="literal">NULL</span>); </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;main: done with both (counter = %d)\n&quot;</span>, counter); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代码，每次运行不会产生错误，但会有不同的结果。</p>
<h3 id="不可控的调度"><a href="#不可控的调度" class="headerlink" title="不可控的调度"></a>不可控的调度</h3><p><strong>竞态条件</strong>(race condition)：结果取决于代码的时间执行。由于在执行过程种发生的上下文切换，我们得到了错误的结果。我们称这个结果是不确定的(indeterminate)。</p>
<p>由于执行这段代码的多个线程可能导致竞争状态，因此我们将此段代码称为<strong>临界区</strong>(critical section)。临界区是访问共享变量（或更一般地说，共享资源）的代码片段，一定不能由多个线程同时执行</p>
<p>解决:互斥</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>解决这个问题的途径是更强大的指令。单步就能完成要做的事，从而消除中断的可能性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memory-add <span class="number">0x8049a</span>lc,$<span class="number">0x1</span></span><br></pre></td></tr></table></figure>

<p>此指令将一个值添加到内存位置，并且以硬件保证它以原子方式(atomically)执行。当执行时，不能被指令中间中断。</p>
<p>要求硬件提供一些有用的指令，可以在这些指令上构建一个通用的集合，即所谓的同步原语(synchronization primitive)。通过使用这些硬件同步原语，加上操作系统的一些帮助，我们能以同步和受控的方式访问临界区。</p>
<blockquote>
<p><strong>临界区、竞态条件、不确定性、互斥执行</strong></p>
<p>临界区(critical section)是访问共享资源的一段代码，资源通常是一个变量或数据结构</p>
<p>竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享的数据结构，导致了令人惊讶的（也许是不希望的）结果。</p>
<p>不确定性（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取决于哪些线程在何时运行。这导致结果不是确定的（deterministic），而我们通常期望计算机系统给出确定的结果</p>
<p>为了避免这些问题，线程应该使用某种互斥（mutual exclusion）原语。这样做可以保证只有一个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。</p>
</blockquote>
<p>那么如何实现同步</p>
<blockquote>
<p><strong>如何实现同步</strong></p>
<p>为了构建有用的同步原语，需要从硬件中获得哪些支持？需要从操作系统中获得什么支持？如何正确有效地构建这些原语？程序如何使用它们来获得期望的结果？</p>
</blockquote>
<h3 id="等待另一个线程"><a href="#等待另一个线程" class="headerlink" title="等待另一个线程"></a>等待另一个线程</h3><p>线程之间的交互，不仅仅只有访问共享变量。<strong>还有一个线程等待另一个线程完成某些操作。</strong>如当进程执行磁盘I&#x2F;O并进入睡眠状态时，会产生这种。</p>
<h3 id="为什么要研究并发"><a href="#为什么要研究并发" class="headerlink" title="为什么要研究并发"></a>为什么要研究并发</h3><p>为什么是并发。<strong>操作系统是第一个并发程序</strong>，很多技术都是在操作系统内部使用的。从引入中断开始，就开始考虑如何更新内部结构。</p>
<blockquote>
<p><strong>使用原子操作</strong></p>
<p>原子操作是构建计算机系统的最强大的基础技术之一，从计算机体系结构到并行代码（我们在这里研究的内容）、文件系统（我们将很快研究）、数据库管理系统，甚至分布式系统</p>
<p>&#x3D;&#x3D;要么都发生，要么都不发生，没有中间状态&#x3D;&#x3D;</p>
</blockquote>
<h2 id="线程API"><a href="#线程API" class="headerlink" title="线程API"></a>线程API</h2><p>创建线程等相关API请自行百度，此处仅简单描述部分。</p>
<h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>:lock:</p>
<p>通过锁(lock)来提供互斥进入临界区的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> *mutex)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">pthread_mutex_t</span> lock;</span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">x = x + <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br><span class="line"><span class="comment">//两个问题，初始化锁以及检测函数成功调用</span></span><br></pre></td></tr></table></figure>

<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>**条件变量(condition variable):**当线程之间必须发生某种信号时，如果一个线程在等待另一个线程继续执行某些操作，条件变量就很有用。&#x3D;&#x3D;条件变量需要锁的保证&#x3D;&#x3D;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_wait</span><span class="params">(<span class="type">pthread_cond_t</span> *cond,<span class="type">pthread_mutex_t</span> *mutex)</span>;<span class="comment">//休眠，等待信号</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_cond_signal</span><span class="params">(<span class="type">pthread_cond_t</span> *cond)</span>;<span class="comment">//发送信号</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">等待操作有两个参数，信号有一个参数</span></span><br><span class="line"><span class="comment">等待调用除了时调用线程进入休眠，还会释放锁。</span></span><br><span class="line"><span class="comment">pthread_cond_wait()会重新获得锁。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>线程API指导</strong></p>
<p>当你使用 POSIX 线程库（或者实际上，任何线程库）来构建多线程程序时，需要记住一些小而重要的事情：</p>
<p>  <strong>保持简洁</strong>。最重要的一点，线程之间的锁和信号的代码应该尽可能简洁。复杂的线程交互容易产生缺陷。</p>
<p>  <strong>让线程交互减到最少</strong>。尽量减少线程之间的交互。每次交互都应该想清楚，并用验证过的、正确的方法来实现（很多方法会在后续章节中学习）。</p>
<p>  <strong>初始化锁和条件变量</strong>。未初始化的代码有时工作正常，有时失败，会产生奇怪的结果。</p>
<p>  <strong>检查返回值</strong>。当然，任何 C 和 UNIX 的程序，都应该检查返回值，这里也是一样。否则会导致古怪而难以理解的行为，让你尖叫，或者痛苦地揪自己的头发。</p>
<p>  <strong>注意传给线程的参数和返回值</strong>。具体来说，如果传递在栈上分配的变量的引用，可能就是在犯错误。</p>
<p>  <strong>每个线程都有自己的栈</strong>。类似于上一条，记住每一个线程都有自己的栈。因此，线程局部变量应该是线程私有的，其他线程不应该访问。线程之间共享数据，值要在堆（heap）或者其他全局可访问的位置。</p>
<p>  <strong>线程之间总是通过条件变量发送信号</strong>。切记不要用标记变量来同步。</p>
<p>  <strong>多查手册</strong>。尤其是 Linux 的 pthread 手册，有更多的细节、更丰富的内容。请仔细阅读！</p>
</blockquote>
<h2 id="锁-1"><a href="#锁-1" class="headerlink" title="锁"></a>锁</h2><p>锁解决的问题:为了原子式执行一系列指令。</p>
<h3 id="锁的基本思想"><a href="#锁的基本思想" class="headerlink" title="锁的基本思想"></a>锁的基本思想</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">lock_t</span> mutex;</span><br><span class="line">...</span><br><span class="line">lock(&amp;mutex);</span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>

<p>锁是一个变量，因此我们需要声明一个某种类型的锁变量(lock variable)才能使用。锁变量保存了锁在某一时刻的状态。</p>
<p>锁的状态:</p>
<ol>
<li>可用的(available,unlocked,free),表示没有线程持有锁</li>
<li>被占用的(acquired,locked,held)表示一个线程持有锁，处于临界区</li>
</ol>
<p>锁为程序员提供了最小程度的调度控制，我们把线程视为程序员创建的实体，但是被操作系统调度，具体方式由操作系统选择。锁让程序员获得一些控制权。通过给临界区加锁，可以保证临界区内只有一个线程活跃。锁将原本由操作系统调度的混乱状态变得更为可控。</p>
<h3 id="Pthread锁"><a href="#Pthread锁" class="headerlink" title="Pthread锁"></a>Pthread锁</h3><p>POSIX库将锁称为互斥量(mtex)，因为它被用来提供线程之间的互斥。即<strong>当一个线程在临界区时，它能够阻止其他线程进入直到本线程离开临界区。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">pthread_mutex_t</span> lock = PTHREAD_MUTEX_INITIALIZER;</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;lock);</span><br><span class="line">balance = balance + <span class="number">1</span>;</span><br><span class="line">pthread_mutex_unlock(&amp;lock);</span><br></pre></td></tr></table></figure>

<p>通常，会使用不同的锁保护不同的数据和结构，从而允许更多的线程进入临界区。</p>
<h3 id="实现一个锁"><a href="#实现一个锁" class="headerlink" title="实现一个锁"></a>实现一个锁</h3><p>如何实现一个锁？需要声明硬件支持？需要声明操作系统的支持？</p>
<blockquote>
<p><strong>如何实现一个锁</strong></p>
<p>如何构建&#x3D;&#x3D;高效&#x3D;&#x3D;的锁？高效的锁能够以低成本提供互斥，同时实现一些特性。</p>
</blockquote>
<h3 id="评价锁"><a href="#评价锁" class="headerlink" title="评价锁"></a>评价锁</h3><p>如何评价一种锁实现的效果:</p>
<ol>
<li>提供互斥(mutual exclusion)。</li>
<li>公平性(fairness)</li>
<li>性能(performance)</li>
</ol>
<h3 id="控制中断"><a href="#控制中断" class="headerlink" title="控制中断"></a>控制中断</h3><p>最早提供的互斥解决方案：在临界区关闭中断。</p>
<p><strong>临界区关闭中断</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">    DisableInterrupts();</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">    EnableInterrupts();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点:</strong></p>
<ol>
<li>简单(没有中断，线程可用确信它的代码会继续执行下去，不会受到干扰)</li>
</ol>
<p><strong>缺点:</strong></p>
<ol>
<li>打开关闭中断是特权操作，不能被滥用。程序开始时调用lock，恶意占用处理器</li>
<li>不支持多处理器。关闭中断并不能保证多个线程在不同的CPU，其不能都进入同一个临界区。线程可以运行在其他处理器上，因此能够进入临界区</li>
<li>关闭中断导致中断丢失，可能会导致严重的系统问题。假如磁盘设备完成了读取请求，但 CPU 错失了这一事实，那么，操作系统如何知道去唤醒等待读取的进程？</li>
<li>效率低。关闭和打开中断的代码执行得较慢</li>
</ol>
<h3 id="测试并设置指令"><a href="#测试并设置指令" class="headerlink" title="测试并设置指令"></a>测试并设置指令</h3><p>最简单的硬件支持是<strong>测试并设置指令</strong>(test-and-set instruction)，也叫<strong>原子交换</strong>(atomic exchange)。</p>
<p>实现一个不依赖原子交换的锁，用一个变量标记锁是否被持有。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(mutex-&gt;flag == <span class="number">1</span>)</span><br><span class="line">        ;<span class="comment">//spin-wait</span></span><br><span class="line">    mutex-&gt;flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *mutex)</span></span><br><span class="line">&#123;</span><br><span class="line">    mutex-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>缺点:</p>
<ol>
<li>正确性，这种方式并不能提供可靠的互斥</li>
<li>性能:线程在等待被持有的锁时，采用了自旋等待(spin-waiting)技术，不停地检测标志的值。自旋等待在等待其他线程释放锁的时候会浪费时间。尤其是在单处理器上，一个等待线程等待的目标线程甚至无法运行（至少在上下文切换之前）</li>
</ol>
<h3 id="实现可用的自旋锁"><a href="#实现可用的自旋锁" class="headerlink" title="实现可用的自旋锁"></a>实现可用的自旋锁</h3><p>硬件指令支持的自旋锁</p>
<p>测试并设置指令(test-and-set):</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//C语言来表示该指令大概的形式</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">TestAndSet</span><span class="params">(<span class="type">int</span> *old_ptr,<span class="type">int</span> new)</span>&#123;</span><br><span class="line">    <span class="type">int</span> old = *old_ptr;	<span class="comment">//fetch old valur at old_ptr</span></span><br><span class="line">    *old_ptr = new;		<span class="comment">//store &#x27;new&#x27; into old_ptr</span></span><br><span class="line">    <span class="keyword">return</span> old;			<span class="comment">//return the old value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回old_ptr指向的旧值，并<strong>同时</strong>更新为new的新值。(当然，是原子地atomically执行)。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> flag; </span><br><span class="line">&#125; <span class="type">lock_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">	<span class="comment">// 0 indicates that lock is available, 1 that it is held </span></span><br><span class="line">	lock-&gt;flag = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">	<span class="keyword">while</span> (TestAndSet(&amp;lock-&gt;flag, <span class="number">1</span>) == <span class="number">1</span>) </span><br><span class="line">	; <span class="comment">// spin-wait (do nothing) </span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">	lock-&gt;flag = <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将测试(test旧的锁值)和设置(set新的值)合并为一个原子操作后，保证了只有一个线程能获取锁。</p>
<p>一直直旋，直到锁可用。在单处理器上，需要抢占式的调度器(preemptive scheduler，不断通过时钟中断一个线程，运行其他线程)，否则，自旋锁无法在单CPU上使用，因为一个自旋的线程永远不会放弃 CPU。</p>
<blockquote>
<p><strong>恶意调度程序的角度思考并发</strong></p>
<p>假装一个恶意调度程序（malicious scheduler），会最不合时宜地中断线程，从而挫败它们在构建同步原语方面的微弱尝试。</p>
</blockquote>
<h3 id="自旋锁的评价"><a href="#自旋锁的评价" class="headerlink" title="自旋锁的评价"></a>自旋锁的评价</h3><ol>
<li>正确性(correctness)：自旋锁保证了互斥，所以是正确的</li>
<li>公平性(fairness):能够保证一个等待线程会进入临界区吗？答案是自旋锁不提供任何公平性保证。实际上，自旋的线程在竞争条件下可能会永远自旋。自旋锁没有公平性，可能会导致饿死。</li>
<li>性能:<ol>
<li>单CPU：每个线程都会自旋一个时间片，浪费CPU周期</li>
<li>多CPU：效果还行</li>
</ol>
</li>
</ol>
<h3 id="比较并交换"><a href="#比较并交换" class="headerlink" title="比较并交换"></a>比较并交换</h3><p>某些系统提供了一个指令:比较并交换指令(compare-and-exchange)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//compare-and-exchange的伪代码</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">CompareAndSwap</span><span class="params">(<span class="type">int</span> *ptr,<span class="type">int</span> expected,<span class="type">int</span> new)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> actual = *ptr;</span><br><span class="line">    <span class="keyword">if</span>(actual == expected)</span><br><span class="line">        *ptr = new;</span><br><span class="line">   	<span class="keyword">return</span> actual;</span><br><span class="line">  	<span class="comment">//将交换并入了指令中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//比较并交换的基本思路是检测 ptr 指向的值是否和 expected 相等；如果是，更新 ptr 所指的值为新值。否则，什么也不做。不论哪种情况，都返回该内存地址的实际值，让调用者能够知道执行是否成功</span></span><br></pre></td></tr></table></figure>

<p>比较并交换指令比测试并设置更强大，但实现简单的自旋锁，它们行为等价。</p>
<h3 id="链接的加载和条件式存储指令"><a href="#链接的加载和条件式存储指令" class="headerlink" title="链接的加载和条件式存储指令"></a>链接的加载和条件式存储指令</h3><p>一些平台提供了这对指令来实现临界区。链接的加载(load-linked)和条件式存储(store-conditional)可用配合使用，实现其他并发结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LoadLinked</span><span class="params">(<span class="type">int</span> *ptr)</span> &#123; </span><br><span class="line">	<span class="keyword">return</span> *ptr; </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">int</span> <span class="title function_">StoreConditional</span><span class="params">(<span class="type">int</span> *ptr, <span class="type">int</span> value)</span> &#123; </span><br><span class="line">    <span class="keyword">if</span> (no one has updated *ptr since the LoadLinked to this address) &#123;</span><br><span class="line">        *ptr = value; </span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>; <span class="comment">// success! </span></span><br><span class="line">	&#125;<span class="keyword">else</span> &#123; </span><br><span class="line">	 	<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// failed to update </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接的加载(load-linked)：从内存中取出值存入一个寄存器。</p>
<p>条件式存储(store-conditional)：只有上一次加载的地址在期间都没有更新时，才会成功。(同时更新刚才链接的加载的地址的值)。成功时，条件存储返回1，并将ptr的值更新为value。失败时，返回0，并且不会更新值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(LoadLinked(&amp;lock-&gt;flag)==<span class="number">1</span>)</span><br><span class="line">            ;<span class="comment">//spin until it&#x27;s zero</span></span><br><span class="line">        <span class="keyword">if</span>(StoreConditional(&amp;lock-&gt;flag,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span>&#123;</span><br><span class="line">    lock-&gt;flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取并增加"><a href="#获取并增加" class="headerlink" title="获取并增加"></a>获取并增加</h3><p>获取并增加(fetch-and-add)指令，能原子地返回特定地址的旧址，并且让该值自增一。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">FetchAndAdd</span><span class="params">(<span class="type">int</span> *ptr)</span>&#123;</span><br><span class="line">    <span class="type">int</span> old = *ptr;</span><br><span class="line">    *ptr = old + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> ticket; </span><br><span class="line">	<span class="type">int</span> turn; </span><br><span class="line">&#125; <span class="type">lock_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">	lock-&gt;ticket = <span class="number">0</span>; </span><br><span class="line">	lock-&gt;turn = <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">	<span class="type">int</span> myturn = FetchAndAdd(&amp;lock-&gt;ticket); </span><br><span class="line">	<span class="keyword">while</span> (lock-&gt;turn != myturn) </span><br><span class="line">		; <span class="comment">// spin </span></span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *lock)</span> &#123; </span><br><span class="line">	FetchAndAdd(&amp;lock-&gt;turn); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>基本操作也很简单：如果线程希望获取锁，首先对一个 ticket 值执行一个原子的获取并相加指令。这个值作为该线程的“turn”（顺位，即 myturn）。根据全局共享的 lock-&gt;turn 变量，当某一个线程的（myturn &#x3D;&#x3D; turn）时，则轮到这个线程进入临界区。unlock 则是增加 turn，从而下一个等待线程可以进入临界区。</p>
<h3 id="自旋过多-怎么办"><a href="#自旋过多-怎么办" class="headerlink" title="自旋过多:怎么办"></a>自旋过多:怎么办</h3><blockquote>
<p><strong>如何避免自旋</strong></p>
<p>如何让锁不会不必要地自旋，浪费CPU时间?</p>
</blockquote>
<p>自旋过多，导致时间片浪费，CPU仅仅在自旋并等待一个线程是否锁</p>
<h3 id="简单方法-让出"><a href="#简单方法-让出" class="headerlink" title="简单方法:让出"></a>简单方法:让出</h3><p>如果临界区的线程发生了上下文切换，其他线程只能一直自旋，等待被中断的线程重新运行?</p>
<p><strong>在自旋时，放弃CPU:</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;flag,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">        yield();<span class="comment">//give up the CPU</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">()</span>&#123;</span><br><span class="line">    flag = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>yield()系统调用能够让运行(running)态变为就绪(ready)态，从而让其他线程运行。因此，让出线程本质上取消调度(deschedules)了自己。</p>
<p><strong>缺点:</strong></p>
<ol>
<li>上下文切换，造成了很大的开销和浪费</li>
<li>饿死的情况。</li>
</ol>
<h3 id="使用队列-休眠替代自旋"><a href="#使用队列-休眠替代自旋" class="headerlink" title="使用队列:休眠替代自旋"></a>使用队列:休眠替代自旋</h3><p>显式地施加某种控制，决定锁释放时，谁能抢到锁。<strong>为了做到该点，我们需要操作系统的更多支持以及一个队列老保存等待锁的线程</strong></p>
<p>park()能够让调用线程休眠，unpark(threadID)会唤醒threadID标识的线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_t</span> &#123;</span></span><br><span class="line">	<span class="type">int</span> flag;</span><br><span class="line">    <span class="type">int</span> guard;</span><br><span class="line">    <span class="type">queue_t</span> *q;</span><br><span class="line">&#125;<span class="type">lock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">lock_init</span><span class="params">(<span class="type">lock_t</span> *m)</span>&#123;</span><br><span class="line">	m-&gt;flag = <span class="number">0</span>;</span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    queue_init(m-&gt;q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lock</span><span class="params">(<span class="type">lock_t</span> *m)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;m-&gt;guard,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">        ;<span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span>(m-&gt;flag == <span class="number">0</span>)&#123;</span><br><span class="line">        m-&gt;flag = <span class="number">1</span>;</span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">		queue_add(m-&gt;q,gettid());</span><br><span class="line">        m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">        park();	<span class="comment">//所有线程休眠在这</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">unlock</span><span class="params">(<span class="type">lock_t</span> *m)</span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(TestAndSet(&amp;m-&gt;guard,<span class="number">1</span>)==<span class="number">1</span>)</span><br><span class="line">        ;<span class="comment">//acquire guard lock by spinning</span></span><br><span class="line">    <span class="keyword">if</span>(queue_empty(m-&gt;q))</span><br><span class="line">        m-&gt;flag = <span class="number">0</span>;		<span class="comment">//let go of lock;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        unpark(queue_remove(m-&gt;q));	<span class="comment">//hold lock</span></span><br><span class="line">    m-&gt;guard = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong></p>
<ol>
<li>guard基本上起到的是自旋锁的占用。当自旋等待时间是有限的，仅仅是lock和unlock代码中的几个指令。是合理的</li>
<li>lock()中，线程不能获取锁，会将自己加入队列，设置guard为0.如果park()之后设置guard，是有问题的</li>
<li>唤醒线程时,flag并没有设置为0：&#x3D;&#x3D;不仅没错，还是必需的。&#x3D;&#x3D;线程被唤醒时，就像是从park()调用返回，但是它没有持有guard，所以不能将flag设置为1.因此，我们旧直接把锁从释放的线程传递给下一个获取锁的线程。期间flag不必设置为0</li>
<li>竞争条件。<strong>在park()调用之前，如果一个线程将要park，假定它应该睡到锁可用时，这时切换到另一个线程(比如持有锁的线程)，这可能会导致麻烦。比如，如果该线程随后释放了锁。接下来第一个线程的 park 会永远睡下去（可能）。这种问题有时称为唤醒&#x2F;等待竞争（wakeup&#x2F;waiting race）。为了避免这种情况，我们需要额外的工作。</strong>&#x3D;&#x3D;我的理解是调用了唤醒，但线程并未休眠，并从队列中踢出了，此时再进入休眠&#x3D;&#x3D;</li>
</ol>
<p>separk()解决了这一问题。通过 setpark()，一个线程表明自己马上要 park。如果刚好另一个线程被调度，并且调用了 unpark，那么后续的 park调用就会直接返回，而不是一直睡眠。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">queue_add(m-&gt;q,gettid());</span><br><span class="line">setpark();</span><br><span class="line">m-&gt;guard = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>另一种方法:将guard传入内核。内核能够采取预防措施，保证原子地释放锁，把运行线程移出队列。</p>
<h3 id="不同操作系统，不同实现"><a href="#不同操作系统，不同实现" class="headerlink" title="不同操作系统，不同实现"></a>不同操作系统，不同实现</h3><p>不同操作系统提供了类似支持，但细节不同。</p>
<p>如Linux提供了futex，提供了更多内核功能。每个futex都关联一个特定的物理内存位置，也有一个事先建好的内核队列。调用者通过futex调用来唤醒或休眠。</p>
<p>调用futex_wait(address,expected)时，如果address处的值等于expected,就会让调用线程休眠。否则，调用返回。调用futex_wake(address)唤醒等待队列中的一个线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mutex_lock</span> <span class="params">(<span class="type">int</span> *mutex)</span> &#123; </span><br><span class="line">	<span class="type">int</span> v; </span><br><span class="line">	<span class="comment">/* Bit 31 was clear, we got the mutex (this is the fastpath) */</span> </span><br><span class="line">	<span class="keyword">if</span> (atomic_bit_test_set (mutex, <span class="number">31</span>) == <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	atomic_increment (mutex); </span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123; </span><br><span class="line">		<span class="keyword">if</span> (atomic_bit_test_set (mutex, <span class="number">31</span>) == <span class="number">0</span>) &#123; </span><br><span class="line">			atomic_decrement (mutex); </span><br><span class="line">			<span class="keyword">return</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">/* We have to wait now. First make sure the futex value </span></span><br><span class="line"><span class="comment">13 we are monitoring is truly negative (i.e. locked). */</span> </span><br><span class="line">	v = *mutex; </span><br><span class="line">	<span class="keyword">if</span> (v &gt;= <span class="number">0</span>) </span><br><span class="line">		<span class="keyword">continue</span>; </span><br><span class="line">		futex_wait (mutex, v); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mutex_unlock</span> <span class="params">(<span class="type">int</span> *mutex)</span> &#123; </span><br><span class="line"> <span class="comment">/* Adding 0x80000000 to the counter results in 0 if and only if </span></span><br><span class="line"><span class="comment">there are not other interested threads */</span> </span><br><span class="line"><span class="keyword">if</span> (atomic_add_zero (mutex, <span class="number">0x80000000</span>)) </span><br><span class="line"><span class="keyword">return</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* There are other threads waiting for this mutex, </span></span><br><span class="line"><span class="comment">wake one of them up. */</span> </span><br><span class="line">futex_wake (mutex);</span><br></pre></td></tr></table></figure>

<p>利用一个整数，同时记录锁是否被持有（整数的最高位），以及等待者的个数（整数的其余所有位）。因此，如果锁是负的，它就被持有（因为最高位被设置，该位决定了整数的符号）。它展示了如何优化常见的情况，即没有竞争时：只有一个线程获取和释放锁，所做的工作很少（获取锁时测试和设置的原子位运算，释放锁时原子的加法）。</p>
<h3 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h3><p>两阶段锁(two-phase lock):第一阶段会先自旋一段时间，希望它可以获取锁。如果第一个自旋阶段没有获得锁，第二阶段调用者会睡眠，直到锁可用。</p>
<h2 id="基于锁的并发数据结构"><a href="#基于锁的并发数据结构" class="headerlink" title="基于锁的并发数据结构"></a>基于锁的并发数据结构</h2><p>通过锁可用时数据结构线程安全(thread safe)。</p>
<blockquote>
<p><strong>如何给数据结构加锁</strong></p>
<p>对于特定数据结构，如何加锁才能让该结构功能正确?如何对该数据结构加锁，能够保证高性能，让许多线程同时访问该结构，即并发访问（concurrently）？</p>
</blockquote>
<h3 id="并发计数器"><a href="#并发计数器" class="headerlink" title="并发计数器"></a>并发计数器</h3><p>带有同步机制的计数器</p>
<p><strong>简单但无法扩展</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">counter_t</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> value; </span><br><span class="line">	<span class="type">pthread_mutex_t</span> lock; </span><br><span class="line">&#125; <span class="type">counter_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123; </span><br><span class="line">	c-&gt;value = <span class="number">0</span>; </span><br><span class="line">	Pthread_mutex_init(&amp;c-&gt;lock, <span class="literal">NULL</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">increment</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123; </span><br><span class="line">	Pthread_mutex_lock(&amp;c-&gt;lock); </span><br><span class="line">	c-&gt;value++; </span><br><span class="line">	Pthread_mutex_unlock(&amp;c-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"><span class="type">void</span> <span class="title function_">decrement</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123; </span><br><span class="line">	Pthread_mutex_lock(&amp;c-&gt;lock); </span><br><span class="line">	c-&gt;value--; </span><br><span class="line">	Pthread_mutex_unlock(&amp;c-&gt;lock); </span><br><span class="line">&#125;  </span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">counter_t</span> *c)</span> &#123; </span><br><span class="line">	Pthread_mutex_lock(&amp;c-&gt;lock); </span><br><span class="line">	<span class="type">int</span> rc = c-&gt;value; </span><br><span class="line">	Pthread_mutex_unlock(&amp;c-&gt;lock); </span><br><span class="line">	<span class="keyword">return</span> rc; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/08/07/LoGuXndfDNOb5S3.png" alt="lock-multiThreadCompareSingleThread.png"></p>
<p>理想情况下，多处理上运行的多线程就像单线程一样快</p>
<p><strong>可扩展的计数</strong></p>
<p><strong>懒惰计数器(sloppy counter)</strong>:懒惰计数器通过多个局部计数器和一个全局计数器来实现一个逻辑计数器，其中每个CPU核心有一个局部计数器。如在4个CPU的机器上，有 4 个局部计数器和 1 个全局计数器。除了这些计数器，还有锁：每个局部计数器有一个锁，全局计数器有一个。</p>
<p>如果一个核心上的线程想增加计数器，那就增加它的局部计数器，访问这个局部计数器是通过对应的局部锁同步的。因为每个 CPU 有自己的局部计数器，不同 CPU 上的线程不会竞争，所以计数器的更新操作可扩展性好。</p>
<p><img src="https://s2.loli.net/2023/08/07/afBLpRGSZ6iFgtO.png" alt="lock-counter.png"></p>
<p>为了保持全局计数器更新（以防某个线程要读取该值），局部值会定期转移给全局计数器，方法是获取全局锁，让全局计数器加上局部计数器的值，然后将局部计数器置零。</p>
<p><img src="https://s2.loli.net/2023/08/07/AsxFcJkKUSiW4jn.png" alt="lock-counter-S.png"></p>
<p>这种局部转全局的频度，取决于一个阈值，这里称为 <em>S</em>（表示 sloppiness）。<em>S</em> 越小，懒惰计数器则越趋近于非扩展的计数器。<em>S</em> 越大，扩展性越强，但是全局计数器与实际计数的偏差越大。我们可以抢占所有的局部锁和全局锁（以特定的顺序，避免死锁），以获得精确值，但这种方法没有扩展性。</p>
<p><strong>原理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">counter_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> global;				<span class="comment">//global count</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> glock;	<span class="comment">//global lock</span></span><br><span class="line">	<span class="type">int</span> local[NUMCPUS];		<span class="comment">//local count(per cpu)</span></span><br><span class="line">    <span class="type">pthread_mutex_t</span> llock[NUMCPUS];	<span class="comment">//locks</span></span><br><span class="line">    <span class="type">int</span> threshold;			<span class="comment">//update frequency</span></span><br><span class="line">&#125;<span class="type">counter_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//init: record threshold,locks,values</span></span><br><span class="line"><span class="comment">//		of all locak counts and global count</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">(<span class="type">counter_t</span> *c,<span class="type">int</span> threshold)</span>&#123;</span><br><span class="line">    c-&gt;threshold = threshold;</span><br><span class="line">    </span><br><span class="line">    c-&gt;global = <span class="number">0</span>;</span><br><span class="line">    pthread_mutex_init(&amp;c-&gt;glock,<span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;NUMCPUS;i++)&#123;</span><br><span class="line">        c-&gt;local[i] = <span class="number">0</span>;</span><br><span class="line">        pthread_mutex_init(&amp;c-&gt;llock[i],<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//update:</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update</span><span class="params">(<span class="type">counter_t</span> *c,<span class="type">int</span> threadID,<span class="type">int</span> amt)</span>&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">    c-&gt;local[threadID]+=amt;</span><br><span class="line">    <span class="keyword">if</span>(c-&gt;loacl[threadID]&gt;=c0&gt;threshold)&#123;</span><br><span class="line">        <span class="comment">//update</span></span><br><span class="line">        pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;global+=c-&gt;local[threadID];</span><br><span class="line">        pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">        c-&gt;local[threadID] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;llock[threadID]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">counter_t</span> *c)</span></span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="type">int</span> val = c-&gt;global;</span><br><span class="line">    pthread_mutex_unlock(&amp;c-&gt;glock);</span><br><span class="line">    <span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="并发链表"><a href="#并发链表" class="headerlink" title="并发链表"></a>并发链表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// basic node structure </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> key; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125; <span class="type">node_t</span>; </span><br><span class="line"></span><br><span class="line"> <span class="comment">// basic list structure (one used per list) </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_t</span> &#123;</span> </span><br><span class="line">	<span class="type">node_t</span> *head; </span><br><span class="line">	<span class="type">pthread_mutex_t</span> lock; </span><br><span class="line">&#125; <span class="type">list_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">List_Init</span><span class="params">(<span class="type">list_t</span> *L)</span> &#123; </span><br><span class="line">	L-&gt;head = <span class="literal">NULL</span>;  </span><br><span class="line">	pthread_mutex_init(&amp;L-&gt;lock, <span class="literal">NULL</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">List_Insert</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123; </span><br><span class="line">	<span class="comment">// synchronization not needed </span></span><br><span class="line">	<span class="type">node_t</span> *new = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>)); </span><br><span class="line">	<span class="keyword">if</span> (new == <span class="literal">NULL</span>) &#123; </span><br><span class="line">		perror(<span class="string">&quot;malloc&quot;</span>); </span><br><span class="line">		<span class="keyword">return</span>; </span><br><span class="line">	&#125; </span><br><span class="line">	new-&gt;key = key; </span><br><span class="line"><span class="comment">// just lock critical section </span></span><br><span class="line">	pthread_mutex_lock(&amp;L-&gt;lock); </span><br><span class="line">	new-&gt;next = L-&gt;head; </span><br><span class="line">	L-&gt;head = new; </span><br><span class="line">	pthread_mutex_unlock(&amp;L-&gt;lock);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">List_Lookup</span><span class="params">(<span class="type">list_t</span> *L, <span class="type">int</span> key)</span> &#123; </span><br><span class="line">	<span class="type">int</span> rv = <span class="number">-1</span>; </span><br><span class="line">	pthread_mutex_lock(&amp;L-&gt;lock); </span><br><span class="line">	<span class="type">node_t</span> *curr = L-&gt;head; </span><br><span class="line">	<span class="keyword">while</span> (curr) &#123; </span><br><span class="line">		<span class="keyword">if</span> (curr-&gt;key == key) &#123; </span><br><span class="line">		rv = <span class="number">0</span>; </span><br><span class="line">		<span class="keyword">break</span>; </span><br><span class="line">		&#125; </span><br><span class="line">	curr = curr-&gt;next; </span><br><span class="line">	&#125; </span><br><span class="line">	pthread_mutex_unlock(&amp;L-&gt;lock); </span><br><span class="line">	<span class="keyword">return</span> rv; <span class="comment">// now both success and failure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>过手锁(hand-over-hand locking,也叫锁耦合,lock coupling)</strong></p>
<p>**原理:**每个节点都有一个锁，替代之前整个链表一个锁。遍历链表的时候，首先抢占下一个节点的锁，然后释放当前节点是锁。</p>
<p>从概念上说，过手锁链表有点道理，它增加了链表操作的并发程度。但是实际上，在遍历的时候，每个节点获取锁、释放锁的开销巨大，很难比单锁的方法快。即使有大量的线程和很大的链表，这种并发的方案不一定会比单锁的方案快。也</p>
<h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> value; </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125; <span class="type">node_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">queue_t</span> &#123;</span> </span><br><span class="line">	<span class="type">node_t</span> *head; </span><br><span class="line">	<span class="type">node_t</span> *tail; </span><br><span class="line">	<span class="type">pthread_mutex_t</span> headLock; </span><br><span class="line">	<span class="type">pthread_mutex_t</span> tailLock; </span><br><span class="line">&#125; <span class="type">queue_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue_Init</span><span class="params">(<span class="type">queue_t</span> *q)</span> &#123; </span><br><span class="line">	<span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>)); </span><br><span class="line">	tmp-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">	q-&gt;head = q-&gt;tail = tmp; </span><br><span class="line">	pthread_mutex_init(&amp;q-&gt;headLock, <span class="literal">NULL</span>); </span><br><span class="line">	pthread_mutex_init(&amp;q-&gt;tailLock, <span class="literal">NULL</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Queue_Enqueue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> value)</span> &#123; </span><br><span class="line">	<span class="type">node_t</span> *tmp = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">node_t</span>));</span><br><span class="line">    assert(tmp != <span class="literal">NULL</span>); </span><br><span class="line">	tmp-&gt;value = value; </span><br><span class="line">	tmp-&gt;next = <span class="literal">NULL</span>; </span><br><span class="line">	pthread_mutex_lock(&amp;q-&gt;tailLock); </span><br><span class="line">	q-&gt;tail-&gt;next = tmp; </span><br><span class="line">	q-&gt;tail = tmp; </span><br><span class="line">	pthread_mutex_unlock(&amp;q-&gt;tailLock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Queue_Dequeue</span><span class="params">(<span class="type">queue_t</span> *q, <span class="type">int</span> *value)</span> &#123; </span><br><span class="line">	pthread_mutex_lock(&amp;q-&gt;headLock); </span><br><span class="line">	<span class="type">node_t</span> *tmp = q-&gt;head; </span><br><span class="line">	<span class="type">node_t</span> *newHead = tmp-&gt;next; </span><br><span class="line">	<span class="keyword">if</span> (newHead == <span class="literal">NULL</span>) &#123; </span><br><span class="line">		pthread_mutex_unlock(&amp;q-&gt;headLock); </span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// queue was empty </span></span><br><span class="line">	&#125; </span><br><span class="line">	*value = newHead-&gt;value; </span><br><span class="line">	q-&gt;head = newHead; </span><br><span class="line">	pthread_mutex_unlock(&amp;q-&gt;headLock); </span><br><span class="line">	<span class="built_in">free</span>(tmp); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你会发现有两个锁，一个负责队列头，另一个负责队列尾。这两个锁使得入队列操作和出队列操作可以并发执行，因为入队列只访问 tail 锁，而出队列只访问 head 锁。</p>
<h3 id="并发散列表"><a href="#并发散列表" class="headerlink" title="并发散列表"></a>并发散列表</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BUCKETS (101) </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_t</span> &#123;</span> </span><br><span class="line">	<span class="type">list_t</span> lists[BUCKETS]; </span><br><span class="line">&#125; <span class="type">hash_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Hash_Init</span><span class="params">(<span class="type">hash_t</span> *H)</span> &#123; </span><br><span class="line">	<span class="type">int</span> i; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; BUCKETS; i++) &#123; </span><br><span class="line">		List_Init(&amp;H-&gt;lists[i]); </span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line">Hash_Insert(<span class="type">hash_t</span> *H, <span class="type">int</span> key) &#123; </span><br><span class="line">	<span class="type">int</span> bucket = key % BUCKETS; </span><br><span class="line">	<span class="keyword">return</span> List_Insert(&amp;H-&gt;lists[bucket], key); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">Hash_Lookup</span><span class="params">(<span class="type">hash_t</span> *H, <span class="type">int</span> key)</span> &#123; </span><br><span class="line">	<span class="type">int</span> bucket = key % BUCKETS; </span><br><span class="line">	<span class="keyword">return</span> List_Lookup(&amp;H-&gt;lists[bucket], key); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>散列表是每个链表都有一个锁从而支持很多并发操作。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>控制流变化时，主要获取锁和释放锁；增加并发不一定能提高性能‘有性能问题的时候再做优化。避免不成熟的优化。</p>
<p>我们让整个应用的某一小部分变快，却没有提高整体性能，其实没有价值</p>
<h2 id="条件变量-1"><a href="#条件变量-1" class="headerlink" title="条件变量"></a>条件变量</h2><p>在很多情况下，线程需要检查某一条件(condition)满足后，才会继续运行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//能工作，但性能低下，因为主线程会自旋检查，浪费CPU时间</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> done = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>); </span><br><span class="line">	done = <span class="number">1</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">	 <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>); </span><br><span class="line"> </span><br><span class="line">	<span class="type">pthread_t</span> c; </span><br><span class="line">	Pthread_create(&amp;c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>); <span class="comment">// create child </span></span><br><span class="line">	<span class="keyword">while</span> (done == <span class="number">0</span>) </span><br><span class="line">		; <span class="comment">// spin </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line"><span class="number">1</span>&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>如何等待一个条件?</strong></p>
<p>多线程程序中，一个线程等待某些条件是很常见的。简单的方案是自旋直到条件满足，这是极其低效的，某些情况下甚至是错误的。那么，线程应该如何等待一个条件？</p>
</blockquote>
<h3 id="定义和程序"><a href="#定义和程序" class="headerlink" title="定义和程序"></a>定义和程序</h3><p>线程可以使用条件变量（condition variable），来等待一个条件变成真。条件变量是一个显式队列，当某些执行状态（即条件，condition）不满足时，线程可以把自己加入队列，等待（waiting）该条件。另外某个线程，当它改变了上述状态时，就可以唤醒一个或者多个等待线程（通过在该条件上发信号），让它们继续执行。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> done = <span class="number">0</span>; </span><br><span class="line"><span class="type">pthread_mutex_t</span> m = PTHREAD_MUTEX_INITIALIZER; </span><br><span class="line"><span class="type">pthread_cond_t</span> c = PTHREAD_COND_INITIALIZER; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_exit</span><span class="params">()</span> &#123; </span><br><span class="line">	Pthread_mutex_lock(&amp;m); </span><br><span class="line">	done = <span class="number">1</span>; </span><br><span class="line">	Pthread_cond_signal(&amp;c); </span><br><span class="line">	Pthread_mutex_unlock(&amp;m); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>); </span><br><span class="line">	thr_exit(); </span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">thr_join</span><span class="params">()</span> &#123; </span><br><span class="line">	Pthread_mutex_lock(&amp;m); </span><br><span class="line">	<span class="keyword">while</span> (done == <span class="number">0</span>) <span class="comment">//while?</span></span><br><span class="line">		Pthread_cond_wait(&amp;c, &amp;m); </span><br><span class="line">	Pthread_mutex_unlock(&amp;m); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> &#123; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>); </span><br><span class="line">	<span class="type">pthread_t</span> p; </span><br><span class="line">	Pthread_create(&amp;p, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>); </span><br><span class="line">	thr_join(); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wait()调用有一个参数，它是互斥量。它假定在 wait()调用时，这个互斥量是已上锁状态。wait()的职责是释放锁，并让调用线程休眠（原子地）。当线程被唤醒时（在另外某个线程发信号给它后），它必须重新获取锁，再返回调用者。<strong>这样做是为了避免在线程陷入休眠时，产生竞态条件</strong></p>
<p>此代码运行的两种情况:</p>
<ol>
<li>父线程创建出子线程，但自己继续运行（假设只有一个处理器），然后马上调用 thr_join()等待子线程。在这种情况下，它会先获取锁，检查子进程是否完成（还没有完成），然后调用 wait()，让自己休眠。子线程最终得以运行，打印出“child”，并调用 thr_exit()函数唤醒父进程，这段代码会在获得锁后设置状态变量 done，然后向父线程发信号唤醒它。最后，父线程会运行（从 wait()调用返回并持有锁），释放锁，打印出“parent:end”。</li>
<li>，子线程在创建后，立刻运行，设置变量 done 为 1，调用 signal 函数唤醒其他线程（这里没有其他线程），然后结束。父线程运行后，调用 thr_join()时，发现 done已经是 1 了，就直接返回。</li>
</ol>
<p><strong>为什么父进程使用while，而不是if</strong></p>
<p>以上的锁以及done都是必需的，缺一请自行思考(竞态条件)</p>
<blockquote>
<p><strong>发信号时总是持有锁</strong></p>
<p>尽管并不是所有情况下都严格需要，但有效且简单的做法，还是在使用条件变量发送信号时持有锁。虽然上面的例子是必须加锁的情况，但也有一些情况可以不加锁，而这可能是你应该避免的。因此，为了简单，请在调用 signal 时持有锁（hold the lock when calling signal）</p>
</blockquote>
<h3 id="生产者-x2F-消费者-有界缓冲区-问题"><a href="#生产者-x2F-消费者-有界缓冲区-问题" class="headerlink" title="生产者&#x2F;消费者(有界缓冲区)问题"></a>生产者&#x2F;消费者(有界缓冲区)问题</h3><p><strong>生产者&#x2F;消费者(producer&#x2F;consumer)问题，也叫有界缓冲区(bounded buffer)</strong></p>
<p>假设有一个或多个生产者线程和一个或多个消费者线程。因为有界缓冲区是共享资源，所以我们必须通过同步机制来访问它，以免产生竞态条件。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个简单的例子</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> buffer;</span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">    assert(count == <span class="number">0</span>);</span><br><span class="line">    count = <span class="number">1</span>;</span><br><span class="line">    buffer = value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">get</span><span class="params">()</span>&#123;</span><br><span class="line">    assert(count == <span class="number">1</span>);</span><br><span class="line">    count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> buffer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> loops = (<span class="type">int</span>)arg;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;loops;++i)&#123;</span><br><span class="line">        put(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> tmp = get();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>有问题的方案</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">cond_t</span> cond; </span><br><span class="line"><span class="type">mutex_t</span> mutex; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">	<span class="type">int</span> i; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">		Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1 </span></span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">1</span>) <span class="comment">// p2 </span></span><br><span class="line">			Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// p3 </span></span><br><span class="line">		put(i); <span class="comment">// p4 </span></span><br><span class="line">		Pthread_cond_signal(&amp;cond); <span class="comment">// p5 </span></span><br><span class="line">		Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">	<span class="type">int</span> i; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">		Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1 </span></span><br><span class="line">		<span class="keyword">if</span> (count == <span class="number">0</span>) <span class="comment">// c2 </span></span><br><span class="line">			Pthread_cond_wait(&amp;cond, &amp;mutex); <span class="comment">// c3 </span></span><br><span class="line">		<span class="type">int</span> tmp = get(); <span class="comment">// c4 </span></span><br><span class="line">		Pthread_cond_signal(&amp;cond); <span class="comment">// c5 </span></span><br><span class="line">		Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li>抢占资源</li>
</ol>
<p>两个消费者存在的话，可能导致一个消费者抢占了另一个的资源，导致get触发断言。 <em>T</em>c1 被生产者唤醒后，但在它运行之前，缓冲区的状态改变了（由于 <em>T</em>c2）。<strong>发信号给线程只是唤醒它们，暗示状态发生了变化（在这个例子中，就是值已被放入缓冲区），但并不会保证在它运行之前状态一直是期望的情况。</strong></p>
<p><strong>代替方案:while语句代替if:</strong></p>
<p>不断检查缓冲区是否为空，让消费者进行睡眠,当然，生产者也需要。</p>
<p>&#x3D;&#x3D;总是使用while循环(always use while loop)。虽然有时候不需要重新检查条件，但这样做更加安全&#x3D;&#x3D;</p>
<ol start="2">
<li>唤醒哪个线程？</li>
</ol>
<p>消费者不一定唤醒的是生产者，也可以是另一个消费者。</p>
<p>&#x3D;&#x3D;信号应该有指向性&#x3D;&#x3D;</p>
<p><strong>解决方法:单值缓冲区的生产者&#x2F;消费者方案</strong></p>
<p>用不同的信号量进行唤醒<code>cond_t empty,fill;</code></p>
<p><strong>最终版本</strong></p>
<p>增加更多缓冲区槽位，可以生产和消费多个值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> buffer[MAX]; </span><br><span class="line"><span class="type">int</span> fill = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> use = <span class="number">0</span>; </span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> value)</span> &#123; </span><br><span class="line">	buffer[fill] = value; </span><br><span class="line">	fill = (fill + <span class="number">1</span>) % MAX; </span><br><span class="line">	count++; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123; </span><br><span class="line">	<span class="type">int</span> tmp = buffer[use]; </span><br><span class="line">	use = (use + <span class="number">1</span>) % MAX; </span><br><span class="line">	count--; </span><br><span class="line">	<span class="keyword">return</span> tmp; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">cond_t</span> empty, fill; </span><br><span class="line"><span class="type">mutex_t</span> mutex; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">	<span class="type">int</span> i; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123; </span><br><span class="line">	Pthread_mutex_lock(&amp;mutex); <span class="comment">// p1 </span></span><br><span class="line">	<span class="keyword">while</span> (count == MAX) <span class="comment">// p2 </span></span><br><span class="line">		Pthread_cond_wait(&amp;empty, &amp;mutex); <span class="comment">// p3 </span></span><br><span class="line">	put(i); <span class="comment">// p4 </span></span><br><span class="line">	Pthread_cond_signal(&amp;fill); <span class="comment">// p5 </span></span><br><span class="line">	Pthread_mutex_unlock(&amp;mutex); <span class="comment">// p6 </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> *<span class="title function_">consumer</span><span class="params">(<span class="type">void</span> *arg)</span> &#123; </span><br><span class="line">	<span class="type">int</span> i; </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; loops; i++) &#123;</span><br><span class="line">    	Pthread_mutex_lock(&amp;mutex); <span class="comment">// c1 </span></span><br><span class="line">		<span class="keyword">while</span> (count == <span class="number">0</span>) <span class="comment">// c2 </span></span><br><span class="line">			Pthread_cond_wait(&amp;fill, &amp;mutex); <span class="comment">// c3 </span></span><br><span class="line">		<span class="type">int</span> tmp = get(); <span class="comment">// c4 </span></span><br><span class="line">		Pthread_cond_signal(&amp;empty); <span class="comment">// c5 </span></span><br><span class="line">		Pthread_mutex_unlock(&amp;mutex); <span class="comment">// c6 </span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, tmp); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="覆盖条件"><a href="#覆盖条件" class="headerlink" title="覆盖条件"></a>覆盖条件</h3><p>**覆盖条件(covering condition)**：覆盖所有需要唤醒线程的场景。但会影响性能。</p>
<p><code>pthread_cond_broadcast()</code>代替<code>pthread_cond_signal()</code></p>
<p>例子：分配内存，有两个消费者，一个要10，一个要100。此时一个生产者释放了50可能唤醒100的线程，所有使用broadcast()</p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>使用信号量作为锁和条件变量</p>
<blockquote>
<p><strong>如何使用信号量</strong></p>
<p>如何使用信号量代替锁和条件变量？什么是信号量？什么是二值信号量？用锁和条件变量来实现信号量是否简单？不用锁和条件变量，如何实现信号量？</p>
</blockquote>
<h3 id="信号量的定义"><a href="#信号量的定义" class="headerlink" title="信号量的定义"></a>信号量的定义</h3><p>信号量是由一个整数值的对象。</p>
<p><code>sem_init(&amp;s,0,1)</code>初始化信号量，将它的值初始化为1，可决定是否在多个线程共享。</p>
<p>通过<code>sem_wait(&amp;s)</code>和<code>sem_post(&amp;s)</code>来对信号量进行操作</p>
<p><code>sem_wait()</code>在信号量大于等于1时返回，否则挂起，直到之后的一个<code>post</code>操作</p>
<p><code>sem_post()</code>直接增加信号量的值，如果有等待线程，唤醒其中一个。</p>
<p>最后，当信号量的值为负数时，这个值就是等待线程的个数</p>
<h3 id="二值信号量-锁"><a href="#二值信号量-锁" class="headerlink" title="二值信号量(锁)"></a>二值信号量(锁)</h3><p>使用信号量来实现锁。锁只有两个状态(持有和没持有)，这种用法也叫<strong>二值信号量(binary semaphore)</strong></p>
<p>一个简单的例子</p>
<p><img src="https://s2.loli.net/2023/08/07/5cTmZjq26kBhVev.png" alt="sem_t-process.png"></p>
<h3 id="信号量用作条件变量"><a href="#信号量用作条件变量" class="headerlink" title="信号量用作条件变量"></a>信号量用作条件变量</h3><p>信号量也可用在一个线程暂停执行，等待某一条件成立的场景。等待下次再某些条件(condition)发生变化，所以将信号量作为条件变量(condition variable)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">sem_t</span> s;</span><br><span class="line"><span class="type">void</span> *<span class="title function_">child</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;child\n&quot;</span>);</span><br><span class="line">    sem_post(&amp;s);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    sem_init(&amp;s,<span class="number">0</span>,x);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;parent: begin\n&quot;</span>); </span><br><span class="line">	<span class="type">pthread_t</span> c; </span><br><span class="line">	Pthread_create(c, <span class="literal">NULL</span>, child, <span class="literal">NULL</span>); </span><br><span class="line">	sem_wait(&amp;s); <span class="comment">// wait here for child </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;parent: end\n&quot;</span>); </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>信号量初始值应该为多少？零</p>
<ol>
<li>父线程创建了子线程，但是子线程并没有运行。这种情况下（见表 31.3），父线程调用 sem_wait()会先于子线程调用 sem_post()。我们希望父线程等待子线程运行。为此，唯一的办法是让信号量的值不大于 0。因此，0 为初值。父线程运行，将信号量减为−1，然后睡眠等待；子线程运行的时候，调用 sem_post()，信号量增加为 0，唤醒父线程，父线程然后从 sem_wait()返回，完成该程序。</li>
<li>是子线程在父线程调用 sem_wait()之前就运行结束。子线程会先调用 sem_post()，将信号量从 0 增加到 1。然后当父线程有机会运行时，会调用sem_wait()，发现信号量的值为 1。于是父线程将信号量从 1 减为 0，没有等待，直接从sem_wait()返回</li>
</ol>
<h3 id="生产者-x2F-消费者-有界缓冲区-问题-1"><a href="#生产者-x2F-消费者-有界缓冲区-问题-1" class="headerlink" title="生产者&#x2F;消费者(有界缓冲区)问题"></a>生产者&#x2F;消费者(有界缓冲区)问题</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//互斥，死锁</span></span><br><span class="line"><span class="type">sem_t</span> empty;</span><br><span class="line"><span class="type">sem_t</span> full;</span><br><span class="line"><span class="type">sem_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">producer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;loops;i++)&#123;</span><br><span class="line">        sem_wait(&amp;empty);		<span class="comment">//line p1</span></span><br><span class="line">        sem_wait(&amp;mutex);		<span class="comment">//line p1.5</span></span><br><span class="line">        put(i);					<span class="comment">//line p2</span></span><br><span class="line">        sem_post(&amp;mutex);		<span class="comment">//line p2.5</span></span><br><span class="line">        sem_post(&amp;empty);		<span class="comment">//line p3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">comsumer</span><span class="params">(<span class="type">void</span> *arg)</span>&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; loops;i++)&#123;</span><br><span class="line">        sem_wait(&amp;full);</span><br><span class="line">        sem_wait(&amp;mutex);</span><br><span class="line">        <span class="type">int</span> tmp = get();</span><br><span class="line">        sem_post(&amp;mutex);</span><br><span class="line">        sem_post(&amp;full);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,tmp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    sem_init(&amp;empty,<span class="number">0</span>,MAX);</span><br><span class="line">    sem_init(&amp;full,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    sem_init(&amp;mutex,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="读者-写者锁"><a href="#读者-写者锁" class="headerlink" title="读者-写者锁"></a>读者-写者锁</h3><p>不同的数据结构访问可能需要不同类型的锁。(读写锁)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//rwlock_acquire_lock()获得写锁,rwlock_release_writelock()释放锁</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">rwlock_t</span> &#123;</span> </span><br><span class="line">	<span class="type">sem_t</span> lock; <span class="comment">// binary semaphore (basic lock) </span></span><br><span class="line">	<span class="type">sem_t</span> writelock; <span class="comment">// used to allow ONE writer or MANY readers </span></span><br><span class="line">	<span class="type">int</span> readers; <span class="comment">// count of readers reading in critical section </span></span><br><span class="line">&#125; <span class="type">rwlock_t</span>; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_init</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line">	rw-&gt;readers = <span class="number">0</span>; </span><br><span class="line">	sem_init(&amp;rw-&gt;lock, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">	sem_init(&amp;rw-&gt;writelock, <span class="number">0</span>, <span class="number">1</span>); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line">	sem_wait(&amp;rw-&gt;lock); </span><br><span class="line">	rw-&gt;readers++; </span><br><span class="line">	<span class="keyword">if</span> (rw-&gt;readers == <span class="number">1</span>) </span><br><span class="line">		sem_wait(&amp;rw-&gt;writelock); <span class="comment">// first reader acquires writelock </span></span><br><span class="line">	sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_readlock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line">	sem_wait(&amp;rw-&gt;lock); </span><br><span class="line">	rw-&gt;readers--; </span><br><span class="line">	<span class="keyword">if</span> (rw-&gt;readers == <span class="number">0</span>) </span><br><span class="line">		sem_post(&amp;rw-&gt;writelock); <span class="comment">// last reader releases writelock </span></span><br><span class="line">	sem_post(&amp;rw-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_acquire_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line">	sem_wait(&amp;rw-&gt;writelock); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">rwlock_release_writelock</span><span class="params">(<span class="type">rwlock_t</span> *rw)</span> &#123; </span><br><span class="line">	sem_post(&amp;rw-&gt;writelock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**缺陷:**读者很容易饿死写者。加入了更多开锁，性能上更慢</p>
<h3 id="哲学家就餐问题"><a href="#哲学家就餐问题" class="headerlink" title="哲学家就餐问题"></a>哲学家就餐问题</h3><p>哲学家就餐问题(dining philosopher’s problem)</p>
<p>基本循环:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    think();</span><br><span class="line">    getforks();</span><br><span class="line">    eat();</span><br><span class="line">    putforks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如何实现<code>getforks()</code>和<code>putforks()</code>，保证<strong>没有死锁，没有饿死，并且并发度高</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span> p)</span>&#123;<span class="keyword">return</span> p;&#125;<span class="comment">//左边</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">right</span><span class="params">(<span class="type">int</span> p)</span>&#123;<span class="keyword">return</span> (p+<span class="number">1</span>)%<span class="number">5</span>;&#125;<span class="comment">//右边</span></span><br><span class="line"><span class="type">sem_t</span> forks[<span class="number">5</span>];		<span class="comment">//信号量</span></span><br></pre></td></tr></table></figure>

<p>当所有都拿起左边的时，便会死锁</p>
<p>一种解决方法:破除依赖</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">getforks</span><span class="params">()</span> &#123; </span><br><span class="line">	<span class="keyword">if</span> (p == <span class="number">4</span>) &#123; </span><br><span class="line">	sem_wait(forks[right(p)]); </span><br><span class="line">	sem_wait(forks[left(p)]); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; </span><br><span class="line">	sem_wait(forks[left(p)]); </span><br><span class="line">	sem_wait(forks[right(p)]); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="如何实现信号量"><a href="#如何实现信号量" class="headerlink" title="如何实现信号量"></a>如何实现信号量</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Zem_t</span> &#123;</span> </span><br><span class="line">	<span class="type">int</span> value; </span><br><span class="line">    <span class="type">pthread_cond_t</span> cond; </span><br><span class="line">	<span class="type">pthread_mutex_t</span> lock; </span><br><span class="line">&#125; Zem_t; </span><br><span class="line"> </span><br><span class="line"><span class="comment">// only one thread can call this </span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_init</span><span class="params">(Zem_t *s, <span class="type">int</span> value)</span> &#123; </span><br><span class="line">	s-&gt;value = value; </span><br><span class="line">	Cond_init(&amp;s-&gt;cond); </span><br><span class="line">	Mutex_init(&amp;s-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_wait</span><span class="params">(Zem_t *s)</span> &#123; </span><br><span class="line">	Mutex_lock(&amp;s-&gt;lock); </span><br><span class="line">	<span class="keyword">while</span> (s-&gt;value &lt;= <span class="number">0</span>) </span><br><span class="line">		Cond_wait(&amp;s-&gt;cond, &amp;s-&gt;lock); </span><br><span class="line">	s-&gt;value--; </span><br><span class="line">	Mutex_unlock(&amp;s-&gt;lock); </span><br><span class="line">&#125; </span><br><span class="line"> </span><br><span class="line"><span class="type">void</span> <span class="title function_">Zem_post</span><span class="params">(Zem_t *s)</span> &#123; </span><br><span class="line">	Mutex_lock(&amp;s-&gt;lock); </span><br><span class="line">	s-&gt;value++; </span><br><span class="line">	Cond_signal(&amp;s-&gt;cond); </span><br><span class="line">	Mutex_unlock(&amp;s-&gt;lock); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="常见并发问题"><a href="#常见并发问题" class="headerlink" title="常见并发问题"></a>常见并发问题</h2><blockquote>
<p>&#x3D;&#x3D;如何处理常见的并发缺陷&#x3D;&#x3D;</p>
<p>并发缺陷会有很多常见的模式。了解这些模式是写出健壮、正确程序的第一步</p>
</blockquote>
<h3 id="有哪些类型的缺陷"><a href="#有哪些类型的缺陷" class="headerlink" title="有哪些类型的缺陷"></a>有哪些类型的缺陷</h3><p>两种类型的缺陷:</p>
<ol>
<li>非死锁的缺陷</li>
<li>死锁缺陷</li>
</ol>
<h3 id="非死锁的缺陷"><a href="#非死锁的缺陷" class="headerlink" title="非死锁的缺陷"></a>非死锁的缺陷</h3><ol>
<li>违法原子性缺陷(atomicity violation)</li>
<li>错误顺序缺陷(order violation)</li>
</ol>
<p><strong>违反原子性缺陷</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>:</span><br><span class="line"><span class="keyword">if</span>(thd-&gt;proc_info)&#123;</span><br><span class="line">    <span class="built_in">fputs</span>(thd-&gt;proc_info,...);</span><br><span class="line">&#125;</span><br><span class="line">Thread <span class="number">2</span>:</span><br><span class="line">thd-&gt;proc_info = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<p>违反原子性的定义:违反了多次内存访问中预期的可串行性(代码段本意是原子的，但执行中并没有强制实现原子性)</p>
<p>解决方法：锁</p>
<p><strong>违反顺序缺陷</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Thread <span class="number">1</span>:</span><br><span class="line"><span class="type">void</span> <span class="title function_">init</span><span class="params">()</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mThread = PR_CreateThread(mMain,...);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line">Thread <span class="number">2</span>:</span><br><span class="line"><span class="type">void</span> <span class="title function_">mMain</span><span class="params">(...)</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    mState = mThread-&gt;State;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2中假定mThread已经初始化了</span></span><br></pre></td></tr></table></figure>

<p>违反顺序的定义:两个内存访问的预期顺序被打破</p>
<p>解决方法：条件变量</p>
<h3 id="死锁缺陷"><a href="#死锁缺陷" class="headerlink" title="死锁缺陷"></a>死锁缺陷</h3><p>死锁(deadlock)是并发中经典问题</p>
<blockquote>
<p><strong>如何对付死锁</strong></p>
<p>我们在实现系统时，如何避免或者能够检测、恢复死锁呢？这是目前系统中的真实问题吗？</p>
</blockquote>
<p><strong>产生死锁的条件:</strong></p>
<ul>
<li>互斥:线程对于需要的资源进行互斥的访问</li>
<li>持有并等待:线程持有了资源(例如已将持有的锁)，同时又在等待其他资源(如需要获得的锁)</li>
<li>非抢占:线程获得的资源(例如锁),不能被抢占</li>
<li>循环等待:线程之间存在一个环路，环路上每个线程都额外持有一个资源，而这个资源又是下一个线程要申请的</li>
</ul>
<p>以上4个条件任意一个没有满足，死锁旧不会产生。</p>
<p><strong>解决方法:</strong></p>
<p><strong>1.循环等待:</strong></p>
<p>让代码不会产生循环等待。最直接的方法就是获取锁时提供一个<strong>全序</strong>(total ordering)。严格的顺序避免了循环等待，也就不会产生死锁。</p>
<p><strong>偏序</strong>(partial ordering)是一种有用的方法，安排锁的获取并避免死锁。</p>
<p><strong>2.持有并等待</strong></p>
<p>死锁的持有并等待条件，可以通过原子地抢锁来避免。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lock(prevention);	<span class="comment">//全局锁</span></span><br><span class="line">lock(L1);</span><br><span class="line">lock(L2);</span><br><span class="line">...</span><br><span class="line">unlock(prevention);</span><br></pre></td></tr></table></figure>

<p>不会有不合时宜的线程切换，从而避免了死锁。但不适合封装，因为需要准确知道抢占了哪些锁。</p>
<p><strong>3.非抢占:</strong></p>
<p>在调用unlock之前，都认为锁是被占有的，多个抢锁操作会带来麻烦，，因为我们等待一个锁时，同时持有另一个锁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用trylock()函数，尝试获得锁，或返回-1表示未被占有</span></span><br><span class="line">top:</span><br><span class="line">lock(L1);</span><br><span class="line"><span class="keyword">if</span>(trylock(L2)==<span class="number">-1</span>)&#123;</span><br><span class="line">    unlock(L1);</span><br><span class="line">    <span class="keyword">goto</span> top;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>另一个线程可以使用相同的加锁方式，但不同的加锁顺序，程序不会产生死锁，但会导致活锁(livelock)</strong></p>
<p>活锁：两个线程可能一直重复相同序列，又同时抢锁失败。</p>
<p>解决方法：等待一段时间、</p>
<p><strong>4.互斥</strong></p>
<p>设计无等待(wait-free)数据结构的思想：通过硬件指令，构造处不需要锁的数据结构。如compare-and-swap</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">AtomicIncrement</span><span class="params">(<span class="type">int</span> *value,<span class="type">int</span> amount)</span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">      <span class="type">int</span> old = *value;</span><br><span class="line">    &#125;<span class="keyword">while</span>(CompareAndSwap(value,old,old+amount)==<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过调度避免死锁:</strong></p>
<p>了解全局的信息，包括不同线程在运行中对锁的需求情况，从而使得后续的调度能够避免产生死锁</p>
<p>这种方案适用场景很局限。如：在嵌入式系统中，知道所有任务以及它们需要的锁。</p>
<p><strong>检查和恢复</strong></p>
<p>死锁检测和恢复技术。</p>
<p>死锁检测器定期运行，通过构建资源图来检测循环。</p>
<h2 id="基于事件的并发-进阶"><a href="#基于事件的并发-进阶" class="headerlink" title="基于事件的并发(进阶)"></a>基于事件的并发(进阶)</h2><p>基于事件的并发(event-based concurrency)主要针对两方面的问题:</p>
<ol>
<li>多线程应用中，正确处理并发很有难度</li>
<li>开发者无法控制多线程在某一时刻的调度</li>
</ol>
<blockquote>
<p><strong>关键问题:不用线程，如何构建并发服务器</strong></p>
<p>不用线程，同时保证对并发的控制，避免多线程应用中出现的问题，如何构建一个并发服务器?</p>
</blockquote>
<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>基于事件的并发:等待某事发生；当它发生时，检查事件类型，然后做少量的相应工作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简单的事件循环</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    events = getEvents();</span><br><span class="line">    <span class="keyword">for</span>(e in events)</span><br><span class="line">        processEvent(s);	<span class="comment">//事件处理程序(event handler)，是系统中发生的唯一活动。对调度的显示控制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>事件服务器如何确定是否有消息到达?</p>
<h3 id="重要API-select-或poll"><a href="#重要API-select-或poll" class="headerlink" title="重要API:select()或poll()"></a>重要API:select()或poll()</h3><p>检查是否有任何应该关注的进入I&#x2F;O</p>
<blockquote>
<p><strong>阻塞与非阻塞接口</strong></p>
<p><strong>阻塞（或同步，synchronous）</strong>接口在返回给调用者之前完成所有工作。<strong>非阻塞（或异步，asynchronous）</strong>接口开始一些工作，但立即返回，从而让所有需要完成的工作都在后台完成。</p>
</blockquote>
<h3 id="为何更简单？无须锁"><a href="#为何更简单？无须锁" class="headerlink" title="为何更简单？无须锁"></a>为何更简单？无须锁</h3><p>使用单个 CPU 和基于事件的应用程序，并发程序中发现的问题不再存在。具体来说，因为一次只处理一个事件，所以不需要获取或释放锁。基于事件的服务器不能被另一个线程中断，因为它确实是单线程的。因此，线程化程序中常见的并发性错误并没有出现在基本的基于事件的方法中。</p>
<blockquote>
<p>请勿阻塞基于事件的服务器</p>
<p>基于事件的服务器可以对任务调度进行细粒度的控制。但是，为了保持这种控制，不可以有阻止调用者执行的调用。如</p>
</blockquote>
<h3 id="异步I-x2F-O"><a href="#异步I-x2F-O" class="headerlink" title="异步I&#x2F;O"></a>异步I&#x2F;O</h3><p>异步 I&#x2F;O(asynchronous I&#x2F;O)这些接口使应用程序能够发出 I&#x2F;O 请求，并在 I&#x2F;O 完成之前立即将控制权返回给调用者，另外的接口让应用程序能够确定各种 I&#x2F;O 是否已完成。</p>
<p>基于事件的方法的困难：</p>
<ol>
<li>当系统从单个CPU转向多个CPU时，简单性就消失。为了利用多个CPU，应该加上锁</li>
<li>不能很好地与某些类型的系统活动集成，如分页。</li>
</ol>
<p>Map-Reduce来写并行的数据分析代码</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">guesscyj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/08/03/OS-thread/">http://example.com/2023/08/03/OS-thread/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/08/08/OS-persistently/" title="OS-persistently"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OS-persistently</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/25/stm32-study/" title="stm32-study"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">stm32-study</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">guesscyj</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">20</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">1.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">并发:介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">1.1.1.</span> <span class="toc-text">线程创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%95%B0%E6%8D%AE%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%BA%BB%E7%83%A6"><span class="toc-number">1.1.2.</span> <span class="toc-text">共享数据带来的麻烦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E6%8E%A7%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">1.1.3.</span> <span class="toc-text">不可控的调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7"><span class="toc-number">1.1.4.</span> <span class="toc-text">原子性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E5%8F%A6%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.1.5.</span> <span class="toc-text">等待另一个线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%A0%94%E7%A9%B6%E5%B9%B6%E5%8F%91"><span class="toc-number">1.1.6.</span> <span class="toc-text">为什么要研究并发</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8BAPI"><span class="toc-number">1.2.</span> <span class="toc-text">线程API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">1.2.1.</span> <span class="toc-text">锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">条件变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81-1"><span class="toc-number">1.3.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.1.</span> <span class="toc-text">锁的基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Pthread%E9%94%81"><span class="toc-number">1.3.2.</span> <span class="toc-text">Pthread锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E9%94%81"><span class="toc-number">1.3.3.</span> <span class="toc-text">实现一个锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E9%94%81"><span class="toc-number">1.3.4.</span> <span class="toc-text">评价锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">1.3.5.</span> <span class="toc-text">控制中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.6.</span> <span class="toc-text">测试并设置指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8F%AF%E7%94%A8%E7%9A%84%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">1.3.7.</span> <span class="toc-text">实现可用的自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E8%AF%84%E4%BB%B7"><span class="toc-number">1.3.8.</span> <span class="toc-text">自旋锁的评价</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2"><span class="toc-number">1.3.9.</span> <span class="toc-text">比较并交换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8C%E6%9D%A1%E4%BB%B6%E5%BC%8F%E5%AD%98%E5%82%A8%E6%8C%87%E4%BB%A4"><span class="toc-number">1.3.10.</span> <span class="toc-text">链接的加载和条件式存储指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%B9%B6%E5%A2%9E%E5%8A%A0"><span class="toc-number">1.3.11.</span> <span class="toc-text">获取并增加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E8%BF%87%E5%A4%9A-%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">1.3.12.</span> <span class="toc-text">自旋过多:怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95-%E8%AE%A9%E5%87%BA"><span class="toc-number">1.3.13.</span> <span class="toc-text">简单方法:让出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E9%98%9F%E5%88%97-%E4%BC%91%E7%9C%A0%E6%9B%BF%E4%BB%A3%E8%87%AA%E6%97%8B"><span class="toc-number">1.3.14.</span> <span class="toc-text">使用队列:休眠替代自旋</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%8C%E4%B8%8D%E5%90%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.15.</span> <span class="toc-text">不同操作系统，不同实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81"><span class="toc-number">1.3.16.</span> <span class="toc-text">两阶段锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E9%94%81%E7%9A%84%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">基于锁的并发数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">1.4.1.</span> <span class="toc-text">并发计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%93%BE%E8%A1%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">并发链表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97"><span class="toc-number">1.4.3.</span> <span class="toc-text">并发队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">并发散列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.4.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-1"><span class="toc-number">1.5.</span> <span class="toc-text">条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.1.</span> <span class="toc-text">定义和程序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-x2F-%E6%B6%88%E8%B4%B9%E8%80%85-%E6%9C%89%E7%95%8C%E7%BC%93%E5%86%B2%E5%8C%BA-%E9%97%AE%E9%A2%98"><span class="toc-number">1.5.2.</span> <span class="toc-text">生产者&#x2F;消费者(有界缓冲区)问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.5.3.</span> <span class="toc-text">覆盖条件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.6.</span> <span class="toc-text">信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.1.</span> <span class="toc-text">信号量的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E4%BF%A1%E5%8F%B7%E9%87%8F-%E9%94%81"><span class="toc-number">1.6.2.</span> <span class="toc-text">二值信号量(锁)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%E7%94%A8%E4%BD%9C%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.6.3.</span> <span class="toc-text">信号量用作条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85-x2F-%E6%B6%88%E8%B4%B9%E8%80%85-%E6%9C%89%E7%95%8C%E7%BC%93%E5%86%B2%E5%8C%BA-%E9%97%AE%E9%A2%98-1"><span class="toc-number">1.6.4.</span> <span class="toc-text">生产者&#x2F;消费者(有界缓冲区)问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%94%81"><span class="toc-number">1.6.5.</span> <span class="toc-text">读者-写者锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.6.</span> <span class="toc-text">哲学家就餐问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">1.6.7.</span> <span class="toc-text">如何实现信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%B9%B6%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text">常见并发问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">1.7.1.</span> <span class="toc-text">有哪些类型的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E6%AD%BB%E9%94%81%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">1.7.2.</span> <span class="toc-text">非死锁的缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%BC%BA%E9%99%B7"><span class="toc-number">1.7.3.</span> <span class="toc-text">死锁缺陷</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%B9%B6%E5%8F%91-%E8%BF%9B%E9%98%B6"><span class="toc-number">1.8.</span> <span class="toc-text">基于事件的并发(进阶)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.8.1.</span> <span class="toc-text">事件循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81API-select-%E6%88%96poll"><span class="toc-number">1.8.2.</span> <span class="toc-text">重要API:select()或poll()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E6%9B%B4%E7%AE%80%E5%8D%95%EF%BC%9F%E6%97%A0%E9%A1%BB%E9%94%81"><span class="toc-number">1.8.3.</span> <span class="toc-text">为何更简单？无须锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5I-x2F-O"><span class="toc-number">1.8.4.</span> <span class="toc-text">异步I&#x2F;O</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/08/OS-persistently/" title="OS-persistently">OS-persistently</a><time datetime="2023-08-08T02:19:53.000Z" title="发表于 2023-08-08 10:19:53">2023-08-08</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/03/OS-thread/" title="OS-thread">OS-thread</a><time datetime="2023-08-03T11:26:02.000Z" title="发表于 2023-08-03 19:26:02">2023-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/25/stm32-study/" title="stm32-study">stm32-study</a><time datetime="2023-07-25T10:44:02.000Z" title="发表于 2023-07-25 18:44:02">2023-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/18/OSBlog/" title="OSBlog">OSBlog</a><time datetime="2023-07-18T07:57:45.000Z" title="发表于 2023-07-18 15:57:45">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/14/OS/" title="OS">OS</a><time datetime="2023-07-14T07:26:36.000Z" title="发表于 2023-07-14 15:26:36">2023-07-14</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By guesscyj</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>
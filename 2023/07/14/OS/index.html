<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>OS | BLOG</title><meta name="author" content="guesscyj"><meta name="copyright" content="guesscyj"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《操作系统导论》笔记  虚拟化  并发  持久化  操作系统介绍程序运行时会发生什么:执行指令  处理器c从内存中获取(fetch)一条指令 对其进行解码(decode) 执行(excute)它  实际上，有一类软件负责让程序运行变得容易（甚至允许你同时运行多个程序），允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。这些软件称为操作系统（Operating System，OS）③">
<meta property="og:type" content="article">
<meta property="og:title" content="OS">
<meta property="og:url" content="http://example.com/2023/07/14/OS/index.html">
<meta property="og:site_name" content="BLOG">
<meta property="og:description" content="《操作系统导论》笔记  虚拟化  并发  持久化  操作系统介绍程序运行时会发生什么:执行指令  处理器c从内存中获取(fetch)一条指令 对其进行解码(decode) 执行(excute)它  实际上，有一类软件负责让程序运行变得容易（甚至允许你同时运行多个程序），允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。这些软件称为操作系统（Operating System，OS）③">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png">
<meta property="article:published_time" content="2023-07-14T07:26:36.000Z">
<meta property="article:modified_time" content="2023-08-03T11:24:41.502Z">
<meta property="article:author" content="guesscyj">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2023/07/14/OS/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'OS',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-03 19:24:41'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="BLOG"><span class="site-name">BLOG</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">OS</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-07-14T07:26:36.000Z" title="发表于 2023-07-14 15:26:36">2023-07-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-03T11:24:41.502Z" title="更新于 2023-08-03 19:24:41">2023-08-03</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="OS"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="《操作系统导论》笔记"><a href="#《操作系统导论》笔记" class="headerlink" title="《操作系统导论》笔记"></a>《操作系统导论》笔记</h1><ul>
<li><input checked="" disabled="" type="checkbox"> 虚拟化</li>
<li><input disabled="" type="checkbox"> 并发</li>
<li><input disabled="" type="checkbox"> 持久化</li>
</ul>
<h2 id="操作系统介绍"><a href="#操作系统介绍" class="headerlink" title="操作系统介绍"></a>操作系统介绍</h2><p>程序运行时会发生什么:执行指令</p>
<ol>
<li>处理器c从内存中获取(fetch)一条指令</li>
<li>对其进行解码(decode)</li>
<li>执行(excute)它</li>
</ol>
<p>实际上，有一类软件负责让程序运行变得容易（甚至允许你同时运行多个程序），允许程序共享内存，让程序能够与设备交互，以及其他类似的有趣的工作。这些软件称为操作系统（Operating System，OS）③，因为它们负责确保系统既易于使用又正确高效地运行。</p>
<p>操作系统利用”虚拟化”(virtualzation)，将物理(physical)资源(如处理器、内存或磁盘)转化为更通用、更强大且更易于使用的虚拟形式。因此，有时将操作系统称为虚拟机(virtual machine)</p>
<p>为了利用虚拟机的功能(如运行程序，分配内存或访问文件)操作系统提供了一些接口(API)。由于操作系统提供系统调用(system call)来运行程序、访问内存和设备，并进行其他相关操作。有时也会说操作系统为应用程序提供了一个标准库(standard library)。因为虚拟化让许多程序运行（从而共享 CPU），让许多程序可以同时访问自己的指令和数据（从而共享内存），让许多程序访问设备（从而共享磁盘等），所以操作系统有时被称为资源操理器（resource manager）。每个 CPU、内存和磁盘都是系统的资源（resource），因此操作系统扮演的主要角色就是操理（manage）这些资源，以做到高效或公平，或者实际上考虑其他许多可能的目标</p>
<h3 id="虚拟化CPU"><a href="#虚拟化CPU" class="headerlink" title="虚拟化CPU"></a>虚拟化CPU</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc != <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;usage:cpu&lt;string&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">char</span> *str = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gcc -o cpu cpu.c</code></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">./cpu A &amp; ; ./cpu B&amp;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们只有一个处理器，但多个程序似乎同时运行</span></span><br></pre></td></tr></table></figure>

<p>在硬件的一些帮助下，操作系统负责提供这种假象（illusion），即系统拥有非常多的虚拟 CPU 的假象。将单个 CPU（或其中一小部分）转换为看似无限数量的 CPU，从而让许多程序看似同时运行，这就是所谓的<strong>虚拟化 CPU（virtualizing the CPU）</strong>。</p>
<p>如果两个程序想在特定时间运行，应该运行哪个？操作系统的策略(policy)决定。在操作系统的许多不同的地方采用了一些策略，来回答这类问题，所以我们将在学习操作系统实现的基本机制（mechanism）（例如一一运行多个程序的能力）时研究这些策略。因此，操作系统承担了资源操理器（resource manager）的角色。</p>
<h3 id="虚拟化内存"><a href="#虚拟化内存" class="headerlink" title="虚拟化内存"></a>虚拟化内存</h3><p>现现机器提供的物理内存（physical memory）模型非常简单。内存就是一个字节数组。要读取（read）内存，必须指定一个地址（address），才能访问存储在那里的数据。要写入（write）或更新（update）内存，还必须指定要写入给定地址的数据。</p>
<p>&#x3D;&#x3D;程序将所有数据结构报错在内存中，并通过各种指令访问它们。程序的每个指令都在内存中，因此每次读取指令都会访问内存。&#x3D;&#x3D;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    assert(p!=<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;(%d)memory address of p: %08x\n&quot;</span>,getpid(),(<span class="type">unsigned</span>) p);</span><br><span class="line">    *p = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        *p = *p+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d)p:%d\n&quot;</span>,getpid(),*p);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>关闭系统的地址空间随机化，对此代码进行测序。</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -o mem mem.c</span><br><span class="line">./mem &amp; ./mem &amp; ./mem &amp;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">此程序会在同一地址空间上进行执行，但都独立更新了地址上的值,没有与其他程序共享相同的物理内存</span></span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;操作系统虚拟化内存(virtualint memory)：&#x3D;&#x3D;每个进程访问自己的虚拟地址空间(virtual address space)，操作系统以某种方式映射到机器的物理内存上。一个正在运行的程序中的内存引用不会影响其他进程的地址空间。(虚拟内存机制)对于正在运行的程序，它完全拥有自己的物理内存。但实际情况是，物理内存是由操作系统操理的共享资源。冰</p>
<h3 id="并发-concurrency"><a href="#并发-concurrency" class="headerlink" title="并发(concurrency)"></a>并发(concurrency)</h3><p>并发:多个任务或进程同时执行的能力或现象。具体来说，它涉及多个任务或进程在同一时间段内共享计算机资源并进行并行执行的能力。</p>
<p>操作系统中的并发可分为以下几种形式:</p>
<ol>
<li>进程级并发</li>
<li>线程级并发</li>
<li>指令级并发</li>
<li>数据并行</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">volatile</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> loops;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">worker</span><span class="params">(<span class="type">void</span> *arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;loops;++i)</span><br><span class="line">        counter++;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;usage:threads &lt;value&gt;\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//字符串转换为整数</span></span><br><span class="line">    loops = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="type">pthread_t</span> p1,p2;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial value: %d\n&quot;</span>,counter);</span><br><span class="line">    pthread_create(&amp;p1,<span class="literal">NULL</span>,worker,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_create(&amp;p2,<span class="literal">NULL</span>,worker,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p1,<span class="literal">NULL</span>);</span><br><span class="line">    pthread_join(p2,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Final alue : %d\n&quot;</span>,counter);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>关键问题:如何构建正确的并发程序</p>
<p>如果同一个内存空间中有很多并发执行的线程，如何构建一个正确工作的程序?操作系统需要什么原语?硬件应该提供哪些机制?如何利用它们来解决并发问题</p>
</blockquote>
<p>上述程序增加共享计数的指令:</p>
<ol>
<li>一条将计数器的值从内存加载到寄存器</li>
<li>一条将其递增</li>
<li>将其保存回内存</li>
</ol>
<p>这3条指令并不是以原子方式(atomically)执行的</p>
<h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>在系统内存中，数据容易丢失，因为像DRAM这样的设备以易失(valatile)的方式存储数值。如果断电或系统奔溃，那么内存中的所有数据都会丢失。因此，需要硬件和软件来持久地(persistently)存储数据。</p>
<p>硬件以某种输入&#x2F;输出（Input&#x2F;Output，I&#x2F;O）设备的形式出现。在现现系统中，硬盘驱动器（hard drive）是存储长期保存的信息的通用存储库。操作系统中操理磁盘的软件通常称为文件系统（file system）。因此它负责以可靠和高效的方式，将用户创建的任何文件（file）存储在系统的磁盘上。</p>
<blockquote>
<p>关键问题:如何持久地存储数据</p>
<p>文件系统是操作系统的一部分，负责管理持久的数据。持久性需要哪些技术才能正确地实现？需要哪些机制和策略才能高性能地实现?面对硬件和软件故障，可靠性如何实现？</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fd = open(<span class="string">&quot;/tmp/file&quot;</span>,O_WRONLY|O_CREAT|O_TRUNC,S_IRWXU);</span><br><span class="line">    assert(fd&gt;<span class="number">-1</span>);</span><br><span class="line">    <span class="type">int</span> re = write(fd,<span class="string">&quot;hello world\n&quot;</span>,<span class="number">13</span>);</span><br><span class="line">    assert(rc == <span class="number">13</span>);</span><br><span class="line">    close(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了完成这个任务,该程序向操作系统发出了3个调用</p>
<ol>
<li>第一个是对open()的调用，它打开文件并创建它。</li>
<li>write(),将一些数据写入文件</li>
<li>close(),只是简单地关闭文件，从而表明程序不会再向它写入更多的数据</li>
</ol>
<p>这些系统调用(system call)被称为文件系统(file system)的操作系统部分，然后改系统处理这些请求，并向用户返回某种错误代码。</p>
<p><strong>操作系统为了实际写入磁盘而做了什么:</strong></p>
<ol>
<li>确定新数据将驻留再磁盘上的哪个位置</li>
<li>在文件系统所维护的各种结构中对其进行记录<ol>
<li>向底层存储设备发出I&#x2F;O请求</li>
<li>以读取现有结构或更新(写入)它们</li>
</ol>
</li>
</ol>
<p>让设备代表你执行某项操作是一个复杂而详细的过程。它需要深入了解低级别设备接口及其确切的语义。操作系统提供了一种通过系统调用来访问设备的标准和简单的方法。因此，OS有时被视为标准库(standard library)。</p>
<p><strong>出于性能方面的原因,大多数文件系统首先会延迟这些写操作一段时间，希望将其批量分组为较大的组。</strong></p>
<p><strong>为了处理写入期间系统崩溃的问题，大多数文件系统都包含某种复杂的写入协议,如日志(journaling)或写时复制(copy-on-write),仔细排序写入磁盘的操作，以确保如果在写入序列期间发生故障，系统可以在之后恢复到合理的状态。</strong></p>
<p><strong>为了使不同的通用操作更高效，文件系统采用了许多不同的数据结构和访问方法。</strong></p>
<h3 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h3><p>操作系统取得CPU、内存或磁盘等物理资源(resources),并对它们进行虚拟化(virtualize)。它处理与并发(concurrency)有关的麻烦且棘手的问题。它持久地(persistently)存储文件，从而使它们长期安全。</p>
<p>操作系统的特性们:</p>
<ul>
<li>抽象(abstraction):C不考虑湖北，汇编不考虑逻辑门…</li>
<li>高性能(performance):最小化操作系统的开销。</li>
<li>保护(protection):一个程序恶意或偶然的不良行为不会损耗其他程序</li>
<li>隔离(isolation):让进程彼此隔离</li>
<li>可靠性(reliability):操作系统必须不间断运行</li>
</ul>
<h2 id="抽象-进程-process"><a href="#抽象-进程-process" class="headerlink" title="抽象:进程(process)"></a>抽象:进程(process)</h2><p>操作系统提供的基本抽象-进程</p>
<p>进程的定义:运行中的程序。程序本身没有生命周期，它只是存在磁盘上面的一些指令。是操作系统让这些字节运行起来，发挥作用。</p>
<blockquote>
<p>关键问题:如何提供有许多CPU的假象</p>
<p>虽然只有少量的物理CPU可用，但是操作系统如何提供几乎无数个CPU可用的假象</p>
</blockquote>
<p><strong>操作系统通过虚拟化（virtualizing）CPU 来提供这种假象</strong>。通过让一个进程只运行一个时间片，然后切换到其他进程，操作系统提供了存在多个虚拟 CPU 的假象。这就是时分共享（time sharing）CPU 技术，允许用户如愿运行多个并发进程。潜在的开销就是性能损失，因为如果 CPU 必须共享，每个进程的运行就会慢一点。</p>
<p>要实现 CPU 的虚拟化，要实现得好，操作系统就需要一些低级机制以及一些高级智能。将低级机制称为机制（mechanism）。机制是一些低级方法或协议，实现了所需的功能。例如，上下文切换（context switch），它让操作系统能够停止运行一个程序，并开始在给定的 CPU 上运行另一个程序。</p>
<blockquote>
<p>时分共享（time sharing）是操作系统共享资源所使用的最基本的技术之一。通过允许资源由一个实体使用一小段时间，然后由另一个实体使用一小段时间，如此下去，所谓的资源（例如，CPU 或网络链接）可以被许多人共享。时分共享的自然对应技术是空分共享，资源在空间上被划分给希望使用它的人。例如，磁盘空间自然是一个空分共享资源，因为一旦将块分配给文件，在用户删除文件之前，不可能将它分配给其他文件。</p>
</blockquote>
<h3 id="抽象-进程"><a href="#抽象-进程" class="headerlink" title="抽象:进程"></a>抽象:进程</h3><p>构成进程的是什么?</p>
<p>进程的机器状态(machine state):程序在运行时，可以读取或更新的内容。</p>
<ol>
<li>内存:指令存在内存中。正在运行的程序读取和写入的数据也在内存中。因此进程可以访问的内存(称为地址空间,address space)是该进程的一部分</li>
<li>寄存器:许多指令明确地读取或更新寄存器。</li>
</ol>
<h3 id="进程API"><a href="#进程API" class="headerlink" title="进程API"></a>进程API</h3><ul>
<li>创建(create):创建新进程的方法。shell中键入命令或双击图标</li>
<li>销毁(destroy):有创建就有销毁。进程有些会自行关闭，但有些不会</li>
<li>等待(wait):有时等待进程停止运行是有用的，因此经常提供某种等待接口</li>
<li>其他控制(miscellaneous contrlo):除了杀死或等待进程外，有时还可能有其他控制。如：暂停进程，恢复</li>
<li>状态(statu):接口获取有关进程的状态信息，如运行时间或状态</li>
</ul>
<h3 id="进程创建：更多细节"><a href="#进程创建：更多细节" class="headerlink" title="进程创建：更多细节"></a>进程创建：更多细节</h3><p>操作系统如何启动并运行一个程序？进程创建实际如何进行？</p>
<ol>
<li><p>操作系统将代码和所有静态数据(如初始化变量)加载(load)到内存中，加载到进程的地址空间中</p>
</li>
<li><p>加载完成后，操作系统在运行此进程之前还需要执行其他一些操作。</p>
<ol>
<li>为程序的运行时栈(run-time stack&#x2F;stack)分配内存</li>
<li>操作系统可能为堆(heap)分配一些内存</li>
<li>执行一些其他初始化任务:如文件描述符</li>
</ol>
</li>
<li><p>启动程序，在入口处运行(main)</p>
</li>
</ol>
<p>有些加载在后续更新中，变为了惰性(lazily)加载。使用时加载。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>早期操作系统，进程可处于以下三种状态:</p>
<ul>
<li>运行(running):在运行状态下，进程正在处理器上运行。正在执行指令</li>
<li>就绪(ready):在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行</li>
<li>阻塞(blocked):在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。</li>
</ul>
<p>从就绪到运行意味着该进程已经被调度(scheduled)。从运行转移到就绪意味着该进程已经取消调度(descheduled)。一旦进程被阻塞，OS将保持进程的这种状态，直达发生某种事件。</p>
<h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>进程的相关状态信息。对于停止的进程，寄存器上下文将保存其寄存器的内容。当一个进程停止时，它的寄存器将被保存到这个内存位置。通过恢复这些寄存器（将它们的值放回实际的物理寄存器中），操作系统可以恢复运行该进程。这种技术被称为上下文切换(context switch)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// the registers xv6 will save and restore </span></span><br><span class="line"><span class="comment">// to stop and subsequently restart a process </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">context</span> &#123;</span> </span><br><span class="line"> <span class="type">int</span> eip; </span><br><span class="line"> <span class="type">int</span> esp; </span><br><span class="line"> <span class="type">int</span> ebx; </span><br><span class="line"> <span class="type">int</span> ecx; </span><br><span class="line"> <span class="type">int</span> edx; </span><br><span class="line"> <span class="type">int</span> esi; </span><br><span class="line"> <span class="type">int</span> edi; </span><br><span class="line"> <span class="type">int</span> ebp; </span><br><span class="line">&#125;; </span><br><span class="line"><span class="comment">// the different states a process can be in </span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> &#123;</span> UNUSED, EMBRYO, SLEEPING, </span><br><span class="line"> RUNNABLE, RUNNING, ZOMBIE &#125;; </span><br><span class="line"><span class="comment">// the information xv6 tracks about each process </span></span><br><span class="line"><span class="comment">// including its register context and state </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proc</span> &#123;</span> </span><br><span class="line"> <span class="type">char</span> *mem; <span class="comment">// Start of process memory </span></span><br><span class="line"> uint sz; <span class="comment">// Size of process memory </span></span><br><span class="line"> <span class="type">char</span> *kstack; <span class="comment">// Bottom of kernel stack </span></span><br><span class="line"> <span class="comment">// for this process </span></span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">proc_state</span> <span class="title">state</span>;</span> <span class="comment">// Process state </span></span><br><span class="line"> <span class="type">int</span> pid; <span class="comment">// Process ID </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">parent</span>;</span> <span class="comment">// Parent process </span></span><br><span class="line"> <span class="type">void</span> *chan; <span class="comment">// If non-zero, sleeping on chan </span></span><br><span class="line"> <span class="type">int</span> killed; <span class="comment">// If non-zero, have been killed </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">ofile</span>[<span class="title">NOFILE</span>];</span> <span class="comment">// Open files</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">cwd</span>;</span> <span class="comment">// Current directory </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">context</span> <span class="title">context</span>;</span> <span class="comment">// Switch here to run process </span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span>;</span> <span class="comment">// Trap frame for the </span></span><br><span class="line"> <span class="comment">// current interrupt </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据结构-进程列表(process list)</p>
<p>进程列表，跟踪系统中正在运行的所有程序。有时候人们会存储关于进程的信息的个体结构称为进程控制块(Process Control Block,PCB)</p>
</blockquote>
<h2 id="进程API-1"><a href="#进程API-1" class="headerlink" title="进程API"></a>进程API</h2><p>Unix中的进程创建:fork()和exec()。等待其创建的子进程执行完成wait()</p>
<blockquote>
<p>如何创建并控制进程:</p>
<p>操作系统应该提供怎样的进程来创建及控制接口？如果设计这些接口才能既方便又实用？</p>
</blockquote>
<h3 id="fork-系统调用"><a href="#fork-系统调用" class="headerlink" title="fork()系统调用"></a>fork()系统调用</h3><blockquote>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world(pid:%d)\n&quot;</span>,(<span class="type">int</span>)<span class="built_in">getpid</span>());</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//failed</span></span><br><span class="line">        <span class="built_in">fprintf</span>(stderr,<span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello,I am child (pid:%d)\n&quot;</span>,(<span class="type">int</span>)<span class="built_in">getpid</span>());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello,I am parent of %d (pid:%d)\n&quot;</span>,rc,(<span class="type">int</span>)<span class="built_in">getpid</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子进程并不是完全拷贝了父进程。它拥有自己的地址空间(即自己的私有内存)、寄存器、程序计数器等，但是它从fork()返回的值是不同的。假设我们在<strong>单个</strong>CPU的系统上运行，那么子进程或父进程在此时都有可能运行。CPU调度程序(scheduler)决定了某个时刻哪个进程被执行。</p>
<h3 id="wait-系统调用"><a href="#wait-系统调用" class="headerlink" title="wait()系统调用"></a>wait()系统调用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>*argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>,(<span class="type">int</span>)getpid());</span><br><span class="line">    <span class="type">int</span> rc = fork();</span><br><span class="line">    <span class="keyword">if</span>(rc &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;fork failed\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(rc == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello,I am child (pid:%d)\n&quot;</span>,(<span class="type">int</span>)getpid());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">int</span> wc = wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello,I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>,rc,wc,(<span class="type">int</span>)getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>父进程等待子进程运行完毕，wait()返回，接着输出自己的信息</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>用不同的程序代替当前的程序。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello world (pid:%d)\n&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>()); </span><br><span class="line">	<span class="type">int</span> rc = fork(); </span><br><span class="line"><span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// fork failed; exit </span></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fork failed\n&quot;</span>); </span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child (new process) </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;hello, I am child (pid:%d)\n&quot;</span>, (<span class="type">int</span>) <span class="built_in">getpid</span>()); </span><br><span class="line">	<span class="type">char</span> *myargs[<span class="number">3</span>]; </span><br><span class="line">	myargs[<span class="number">0</span>] = <span class="built_in">strdup</span>(<span class="string">&quot;wc&quot;</span>); <span class="comment">// program: &quot;wc&quot; (word count) </span></span><br><span class="line">	myargs[<span class="number">1</span>] = <span class="built_in">strdup</span>(<span class="string">&quot;p3.c&quot;</span>); <span class="comment">// argument: file to count </span></span><br><span class="line">	myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; <span class="comment">// marks end of array </span></span><br><span class="line">	<span class="built_in">execvp</span>(myargs[<span class="number">0</span>], myargs); <span class="comment">// runs word count </span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;this shouldn&#x27;t print out&quot;</span>); </span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main) </span></span><br><span class="line">	<span class="type">int</span> wc = <span class="built_in">wait</span>(<span class="literal">NULL</span>); </span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;hello, I am parent of %d (wc:%d) (pid:%d)\n&quot;</span>, rc, wc, (<span class="type">int</span>) <span class="built_in">getpid</span>()); </span><br><span class="line">&#125; </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>exec()会从可执行程序中加载代码和静态数据，并用它覆写自己的代码端(静态数据)，堆、栈及其他内存空间也会被重新初始化。</p>
<h3 id="为什么这样设计API"><a href="#为什么这样设计API" class="headerlink" title="为什么这样设计API"></a>为什么这样设计API</h3><p>为什么分离fork()和exec()而不是封装在一起</p>
<blockquote>
<p>做对事，做正确的事</p>
</blockquote>
<p>fork()和exec()分离，可以让shell更方便地实现更多的功能</p>
<p>如<code>&gt;</code> 、<code>|</code>等</p>
<p>重定义(redirect)以及并发</p>
<p>重定义(redirect):修改文件描述符中的标准输入和输出，进行进程间的通信</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span> </span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">	<span class="type">int</span> rc = fork(); </span><br><span class="line">	<span class="keyword">if</span> (rc &lt; <span class="number">0</span>) &#123; <span class="comment">// fork failed; exit </span></span><br><span class="line">	<span class="built_in">fprintf</span>(stderr, <span class="string">&quot;fork failed\n&quot;</span>); </span><br><span class="line">	<span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (rc == <span class="number">0</span>) &#123; <span class="comment">// child: redirect standard output to a file </span></span><br><span class="line">	<span class="built_in">close</span>(STDOUT_FILENO); </span><br><span class="line">	<span class="built_in">open</span>(<span class="string">&quot;./p4.output&quot;</span>, O_CREAT|O_WRONLY|O_TRUNC, S_IRWXU);<span class="comment">// now exec &quot;wc&quot;... </span></span><br><span class="line">	<span class="type">char</span> *myargs[<span class="number">3</span>]; </span><br><span class="line">	myargs[<span class="number">0</span>] = <span class="built_in">strdup</span>(<span class="string">&quot;wc&quot;</span>); <span class="comment">// program: &quot;wc&quot; (word count) </span></span><br><span class="line">	myargs[<span class="number">1</span>] = <span class="built_in">strdup</span>(<span class="string">&quot;p4.c&quot;</span>); <span class="comment">// argument: file to count </span></span><br><span class="line">	myargs[<span class="number">2</span>] = <span class="literal">NULL</span>; <span class="comment">// marks end of array </span></span><br><span class="line">    <span class="built_in">execvp</span>(myargs[<span class="number">0</span>], myargs); <span class="comment">// runs word count </span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123; <span class="comment">// parent goes down this path (main) </span></span><br><span class="line">		<span class="type">int</span> wc = <span class="built_in">wait</span>(<span class="literal">NULL</span>); </span><br><span class="line">&#125; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="机制-受限直接执行"><a href="#机制-受限直接执行" class="headerlink" title="机制:受限直接执行"></a>机制:受限直接执行</h2><p>虚拟化CPU：运行一个进程一段时间，然后运行另一个进程，如此轮换。通过这种方式时分共享(time sharing) CPU。</p>
<p>如何实现:</p>
<ol>
<li>性能:如何在不增加系统开销的情况下实现虚拟化</li>
<li>控制权:如何有效地运行进程，同时保留对CPU的控制。操作系统负责资源管理。(如果没有控制权，一个进程可以简单地无限制运行并接管机器，或访问没有权限的信息。)</li>
</ol>
<blockquote>
<p><strong>如何高效、可控地虚拟化CPU</strong></p>
</blockquote>
<h3 id="受限直接执行"><a href="#受限直接执行" class="headerlink" title="受限直接执行"></a>受限直接执行</h3><p>为了使程序尽可能快地运行。操作系统使用<strong>受限的直接执行(limited direct execution)</strong></p>
<p>**直接执行:**只需直接在CPU上运行程序即可。当 OS 希望启动程序运行时，它会在进程列表中为其创建一个进程条目，为其分配一些内存，将程序代码（从磁盘）加载到内存中，找到入口点（main()函数或类似的），跳转到那里，并开始运行用户的代码。</p>
<p><img src="https://s2.loli.net/2023/07/17/PGv49HfzndelNFB.png" alt="directExec.png"></p>
<p>问题:</p>
<ul>
<li>如果只运行一个程序，操作系统怎么能确保程序不做任何我们不希望它做的事，同时仍然高效地运行它(访问受限的数据)</li>
<li>当运行一个进程时，操作系统如何让它停下来并切换到另一个进程，从而实现虚拟化CPU所需的时分共享</li>
</ul>
<h3 id="受限制的操作"><a href="#受限制的操作" class="headerlink" title="受限制的操作"></a>受限制的操作</h3><p>直接执行的优势是快速，但如果进程希望执行某种受限操作?</p>
<blockquote>
<p><strong>如何执行受限制的操作</strong></p>
<p>一个进程必须能够执行 I&#x2F;O 和其他一些受限制的操作，但又不能让进程完全控制系统。操作系统和硬件如何协作实现这一点？</p>
</blockquote>
<blockquote>
<p>硬件通过提供不同的执行模式来协助操作系统。在用户模式（user mode）下，应用程序不能完全访问硬件资源。在内核模式（kernel mode）下，操作系统可以访问机器的全部资源。还提供了陷入（trap）内核和从陷阱返回（return-from-trap）到用户模式程序的特别说明，以及一些指令，让操作系统告诉硬件陷阱表（trap table）在内存中的位置。</p>
</blockquote>
<p><strong>用户模式</strong>下进程发送IO请求，会导致处理器引发异常，操作系统可能会终止进程。<strong>内核模式</strong>下,运行的代码就可以执行，操作系统就是内核模式下运行</p>
<p>要执行系统调用，程序必须&#x3D;&#x3D;执行&#x3D;&#x3D;<strong>特殊的陷阱（trap）指令</strong>。该指令同时跳入<strong>内核</strong>并将<strong>特权级别提升到内核模式</strong>。一旦进入内核，系统就可以执行任何需要的特权操作（如果允许），从而为调用进程执行所需的工作。完成后，操作系统调用一个<strong>特殊的从陷阱返回（return-from-trap）指令</strong>，如你期望的那样，该指令返回到发起调用的用户程序中，同时将<strong>特权级别降低，回到用户模式</strong>。</p>
<blockquote>
<p><strong>为什么系统调用看起来像过程调用</strong></p>
<p>你可能想知道，为什么对系统调用的调用（如 open()或 read()）看起来完全就像 C 中的典型过程调用。也就是说，如果它看起来像一个过程调用，系统如何知道这是一个系统调用，并做所有正确的事情？原因很简单：它是一个过程调用，但隐藏在过程调用内部的是著名的陷阱指令。更具体地说，当你调用 open()（举个例子）时，你正在执行对 C 库的过程调用。其中，无论是对于 open()还是提供的其他系统调用，库都使用与内核一致的调用约定来将参数放在众所周知的位置（例如，在栈中或特定的寄存器中），将系统调用号也放入一个众所周知的位置（同样，放在栈或寄存器中），然后执行上述的陷阱指令。库中陷阱之后的代码准备好返回值，并将控制权返回给发出系统调用的程序。因此，C 库中进行系统调用的部分是用汇编手工编码的，因为它们需要仔细遵循约定，以便正确处理参数和返回值，以及执行硬件特定的陷阱指令。现在你知道为什么你自己不必写汇编代码来陷入操作系统了，因为有人已经为你写了这些汇编。</p>
</blockquote>
<p>&#x3D;&#x3D;当用户程序遇到需要内核介入的情况是，会触发一个陷阱(trap)或异常。(可以是软件或硬件触发)。发生陷阱时,CPU会将用户程序的上下文保持起来，并将控制权转移到内核模式下的特定处理程序，通常称为陷阱处理程序&#x3D;&#x3D;</p>
<p><strong>陷阱如何知道在OS内运行哪些代码？</strong></p>
<p>显然发起调用的过程，<strong>不能知道跳转到的地址</strong>(异常用户态下的操作)，这样做让程序可以跳转到内核中的任意位置，这显然是不好的注意(在检查文件权限之前，跳转到了访问文件的代码)</p>
<p><strong>内核通过在启动是设置陷阱表(trap table)来实现。</strong>当机器启动时，它在内核模式下执行，因此可以根据需要自由配置机器硬件。<strong>操作系统做的第一件事:告诉硬件在发生某些异常事件是要运行哪些代码。</strong></p>
<p>&#x3D;&#x3D;能够执行指令来告诉硬件陷阱表的位置，是特权操作&#x3D;&#x3D;。时间线拒绝了用户模式修改陷阱表。</p>
<ul>
<li>第一阶段(系统引导时):内核初始化陷阱表，并且CPU记住它的位置以供后续使用。内核通过特权指令来执行此操作</li>
<li>第二阶段(运行进程时):在使用从陷阱返回指令开始执行进程之前，内核设置了一些内容（例如，在进程列表中分配一个节点，分配内存）。</li>
</ul>
<h3 id="在进程之间切换"><a href="#在进程之间切换" class="headerlink" title="在进程之间切换"></a>在进程之间切换</h3><p>如果一个进程在CPU上运行，这就意味着操作系统没有运行。</p>
<blockquote>
<p><strong>关键问题:如何重获CPU的控制权</strong></p>
<p>操作系统如何重新获得CPU的控制权(refain control),以使它可以在线程之间切换</p>
</blockquote>
<p><strong>协作(cooperative)方式:等待系统调用</strong></p>
<p>操作系统相信系统的进程会合理运行，运行时间过长的进程被假定会定期放弃CPU，以便操作系统可以决定运行其他任务。<strong>如何将CPU的控制权交给系统调用：</strong>进程通过系统调用将CPU转交</p>
<blockquote>
<p>处理应用程序的不当行为</p>
<p>操作系统通常必须处理不当行为，这些程序通过设计(而言)或不小心(错误)。尝试做某些不应该做的事情。在现代系统中，操作系统试图处理这种不当行为的方式是简单地终止犯罪者。一击出局！也许有点残酷，但如果你尝试非法访问内存或执行非法指令，操作系统还应该做些什么？</p>
</blockquote>
<p>如果应用程序执行了某些非法操作，也会将控制转移给操作系统。因此，在协作调度系统中，OS通过等待系统调用，或某种非法操作发生，从而重新获得CPU控制权。</p>
<p>那么，如果一个程序一直循环会如何:</p>
<p><strong>非协作方式:操作系统进行控制</strong></p>
<p>时钟中断(timer interupt)：时钟设备可以每隔几毫秒产生一次中断，当前运行的进程停止。操作系统中预先配置的中断处理程序(interupt handler)运行。操作系统重新获得CPU的控制器。</p>
<blockquote>
<p>利用时钟中断重新获得控制权</p>
<p>即使进程以非协作的方式运行，添加时钟中断(timer interupt)也让操作系统能够在CPU上重新运行。</p>
</blockquote>
<p><strong>时钟中断:</strong></p>
<ol>
<li>通知硬件哪些代码在发生时钟中断时运行</li>
<li>在操作系统启动过程中，也启动时钟</li>
</ol>
<p><strong>保存和恢复上下文</strong></p>
<p>既然操作系统重新获得了控制权，无论是通过系统调用协作，还是通过时钟中断强制执行，都必须决定：<strong>是继续运行当前正在运行的进程，还是切换到另一个进程。</strong>&#x3D;&#x3D;是由调度程序(scheduler)决定的。&#x3D;&#x3D;</p>
<p>如果决定切换，OS就会执行一些底层代码,&#x3D;&#x3D;即上下文切换(context switch)。&#x3D;&#x3D;</p>
<p>上下文切换:操作系统为当前正在执行的进程保存一些寄存器的值，并未即将执行的进程恢复一些寄存器的值(从内核栈)。操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p>
<p>为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器、程序计数器，并切换&#x3D;&#x3D;内核栈&#x3D;&#x3D;，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程（被中断的进程）的上下文，在返回时，是另一进程（即将执行的进程的上下文)。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完成。</p>
<p>&#x3D;&#x3D;进程由于中断而陷入内核态，进程进入内核态之后，首先把用户态的堆栈地址保存在内核态堆栈中，然后设置堆栈寄存器地址为内核栈地址，这样就从用户栈切换为了内核栈&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;当进程从内核态转换到用户态时，将堆栈寄存器的地址再重新设置成用户态的堆栈地址（即终端前进程在用户态执行的位置），这一过程也成为现场恢复&#x3D;&#x3D;</p>
<p><strong>内核栈在切换时总是空的</strong></p>
<h3 id="担心并发吗"><a href="#担心并发吗" class="headerlink" title="担心并发吗"></a>担心并发吗</h3><p>当处理一个中断时发生了另一个中断，会发生什么？</p>
<blockquote>
<p>上下文切换要多长时间</p>
<p>你可能有一个很自然的问题：上下文切换需要多长时间？甚至系统调用要多长时间？如果感到好奇，有一种称为 lmbench [MS96]的工具，可以准确衡量这些事情，并提供其他一些可能相关的性能指标。</p>
<p>随着时间的推移，结果有了很大的提高，大致跟上了处理器的性能提高。例如，1996 年在 200-MHz P6CPU 上运行 Linux 1.3.37，系统调用花费了大约 4μs，上下文切换时间大约为 6μs[MS96]。现代系统的性能几乎可以提高一个数量级，在具有 2 GHz 或 3 GHz 处理器的系统上的性能可以达到亚微秒级。</p>
<p>应该注意的是，并非所有的操作系统操作都会跟踪 CPU 的性能。正如 Ousterhout 所说的，许多操作系统操作都是内存密集型的，而随着时间的推移，内存带宽并没有像处理器速度那样显著提高[O90]。因此，根据你的工作负载，购买最新、性能好的处理器可能不会像你希望的那样加速操作系统。</p>
</blockquote>
<p>但是，操作系统可以简单地禁止中断处理期间中断(disable interrupt),但这样就会丢失中断。操作系统还开发了许多复杂的加锁（locking）方案，以保护对内部数据结构的并发访问。这使得多个活动可以同时在内核中进行，特别适用于多处理器。</p>
<h2 id="进程调度-介绍"><a href="#进程调度-介绍" class="headerlink" title="进程调度:介绍"></a>进程调度:介绍</h2><p>运行进程的底层机制(mechanism)如上下文，应该清楚了。操作系统调度程序采用的上层策略(policy)</p>
<blockquote>
<p>如何开发调度策略</p>
<p>我们该如何开发一个调度策略的基本框架？什么是关键假设？哪些指标非常重要？哪些基本方法已经在早期的系统中使用？</p>
</blockquote>
<h3 id="工作负载假设"><a href="#工作负载假设" class="headerlink" title="工作负载假设"></a>工作负载假设</h3><p>工作负载(workload)</p>
<p>假设操作系统中运行的进程有以下过程:</p>
<ol>
<li>每一个工作运行相同的时间</li>
<li>所有的工作同时到达</li>
<li>一旦开始，每个工作保持运行直到完成</li>
<li>所有的工作只是用CPU(无I&#x2F;O操作)</li>
<li>每个工作的运行时间已知</li>
</ol>
<h3 id="调度指标"><a href="#调度指标" class="headerlink" title="调度指标"></a>调度指标</h3><p>调度指标用来比较不同的调度策略。</p>
<p>一个指标:周转时间(turnaround time):任务完成时间减去任务到达系统的时间:</p>
<p>T<del>周转时间</del> &#x3D; T<del>完成时间</del> - T<del>达到时间</del></p>
<p>周转时间是一个性能(performance)指标,另一个指标是公平，但性能和公平是矛盾的</p>
<h3 id="先进先出-FIFO"><a href="#先进先出-FIFO" class="headerlink" title="先进先出(FIFO)"></a>先进先出(FIFO)</h3><p> 最基本的算法：<strong>先进先出(Fitst In First Out)调度</strong></p>
<p><img src="https://s2.loli.net/2023/07/22/ZW6cPa9xVQnBvz1.png" alt="OSpolicy-FIFO.png"></p>
<p>如果ABC同时到达，A运行100s,B、C10s，这样平均周转时间为110s</p>
<p>这种问题被称为护航效应(convoy effect)。</p>
<blockquote>
<p>SJF原则</p>
<p>最短任务优先代表一个总体调度原则，可以应用于所有系统，只要其中平均客户周转时间很重要。</p>
</blockquote>
<h3 id="最短任务优先-SJF"><a href="#最短任务优先-SJF" class="headerlink" title="最短任务优先(SJF)"></a>最短任务优先(SJF)</h3><p><strong>最短任务优先(Shortest Job First)</strong>:先运行最短的任务，然后是次短的任务。(非抢占(preempt))</p>
<p>在假设所有工作同时到达时，这是最优(optimal)的调度算法</p>
<blockquote>
<p>补充：抢占式调度程序(non-preemptive)</p>
<p>这样的系统会将每项工作做完，再考虑是否运行新工作。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/22/tuaUj4wLYzqXfQp.png" alt="OSpolicy-SJF.png"></p>
<p>BC在A之后到达，却仍然要等到A完成，遭遇了同样的护航问题。</p>
<h3 id="最短完成时间优先-STCF"><a href="#最短完成时间优先-STCF" class="headerlink" title="最短完成时间优先(STCF)"></a>最短完成时间优先(STCF)</h3><p>向SJF添加抢占，称为<strong>最短完成时间优先</strong>(Shortest Time-to-Completion First,STCF)或抢占式最短作业优先(Preemptive Shortest Job First,PSJF)调度程序。</p>
<p><img src="https://s2.loli.net/2023/07/22/CWSd91KfRoHq7Xh.png" alt="OSpolicy-SCTC.png"></p>
<h3 id="新度量指标-响应时间"><a href="#新度量指标-响应时间" class="headerlink" title="新度量指标:响应时间"></a>新度量指标:响应时间</h3><p>STCF是一个很好的策略。然而，引入分时系统改变了这一切。要求系统的交互性好，引入了新度量指标:<strong>响应时间(response time)。</strong></p>
<p>**响应时间:**从任务到达系统到首次运行的时间:</p>
<p>​	T<del>响应时间</del>&#x3D; T<del>首次运行</del>-T<del>到达时间</del></p>
<p>STCF和相关方法在响应时间上并不是很好。例如3个工作同时到达，第三个工作必须等待前两个工作圈闭运行后才能运行。这种方法虽然有好的周转时间，但响应时间和交互性很差。</p>
<h3 id="轮转-RR"><a href="#轮转-RR" class="headerlink" title="轮转(RR)"></a>轮转(RR)</h3><p><strong>轮转(Round-Robin,RR)</strong>:RR在一个时间片(time slice)内运行一个工作，然后切换好运行队列中的下一个任务，而不是运行一个任务直到结束。时间片长度必须是时钟中断周期的倍数。</p>
<p>假设3个任务A、B和C在系统中同时到达，并且都希望运行5s。</p>
<p><img src="https://s2.loli.net/2023/07/22/3udDFfzsGmgP6ow.png" alt="OSpolicy-RR.png"></p>
<p>RR的平均响应时间是:(0+1+2)&#x2F;3 &#x3D; 1;算法平均响应时间是(0+5+10)&#x2F;3 &#x3D; 5。时间片长度对于RR至关重要。&#x3D;&#x3D;越短，RR在响应时间上表现越好。但太短：上下文的切换成本将影响性能。所以时间片的长度适当，以便摊销(amortize)上下文切换成本，而不使系统不及时响应。&#x3D;&#x3D;</p>
<blockquote>
<p>摊销可以减少成本</p>
<p>当系统某些操作有作有固定成本时，通常会使用摊销技术(amortization)。通过减少成本的频度（即执行较少次的操作），系统的总成本就会降低。例如，如果时间片设置为 10ms，并且上下文切换时间为 1ms，那么浪费大约 10%的时间用于上下文切换。如果要摊销这个成本，可以把时间片增加到 100ms。在这种情况下，不到 1%的时间用于上下文切换，因此时间片带来的成本就被摊销了。</p>
</blockquote>
<p>上下文切换的成本不仅仅来自保存和恢复少量寄存器的操作系统操作。程序运行时，它们在<strong>CPU高速缓存、TLB、分支预测器和其他片上硬件中建立了大量的状态。切换到另一个工作会导致此状态被刷新，且与当前运行的作业相关的新状态被引入</strong></p>
<blockquote>
<p>重叠可以提高利用率</p>
<p>如有可能，重叠(overlap)操作可以最大限度地提高系统的利用率。重叠在许多不同的领域很有用，包括执行磁盘 I&#x2F;O 或将消息发送到远程机器时。在任何一种情况下，开始操作然后切换到其他工作都是一个好主意，这也提高了系统的整体利用率和效率。</p>
</blockquote>
<h3 id="结合I-x2F-O"><a href="#结合I-x2F-O" class="headerlink" title="结合I&#x2F;O"></a>结合I&#x2F;O</h3><p>调度请求在工作发起I&#x2F;O请求时做出决定，因为当前正在运行的作业在I&#x2F;O期间不会使用CPU，<strong>被阻塞等待I&#x2F;O完成</strong>。</p>
<p><img src="https://s2.loli.net/2023/07/22/7IVwAeQcSXHnfGs.png" alt="OSpolicy-IO.png"></p>
<p>让我们假设有两项工作 A 和 B，每项工作需要 50ms 的 CPU时间。但是，有一个明显的区别：A 运行 10ms，然后发出 I&#x2F;O 请求（假设 I&#x2F;O 每个都需要10ms），而 B 只是使用 CPU 50ms，不执行 I&#x2F;O。调度程序先运行 A，然后运行 B（见图 7.8）。</p>
<p>假设我们正在尝试构建 STCF 调度程序。这样的调度程序应该如何考虑到这样的事实，即 A 分解成 5 个 10ms 子工作，而 B 仅仅是单个 50ms CPU 需求？显然，仅仅运行一个工作，然后运行另一个工作，而不考虑如何考虑 I&#x2F;O 是没有意义的。</p>
<p>一种常见的方法是将 A 的每个 10ms 的子工作视为一项独立的工作。因此，当系统启动时，它的选择是调度 10ms 的 A，还是 50ms 的 B。对于 STCF，选择是明确的：选择较短的一个，在这种情况下是 A。然后，A 的工作已完成，只剩下 B，并开始运行。然后提交 A的一个新子工作，它抢占 B 并运行 10ms。这样做可以实现重叠（overlap），一个进程在等待另一个进程的 I&#x2F;O 完成时使用 CPU，系统因此得到更好的利用（见图 7.9）。</p>
<p>这样我们就看到了调度程序可能如何结合 I&#x2F;O。通过将每个 CPU 突发作为一项工作，调度程序确保“交互”的进程经常运行。当这些交互式作业正在执行 I&#x2F;O 时，其他 CPU 密集型作业将运行，从而更好地利用处理器</p>
<h3 id="无法预知"><a href="#无法预知" class="headerlink" title="无法预知"></a>无法预知</h3><p>在一个通用的操作系统中，操作系统通常对每个作业的长度知之甚少，因此，我们如何建立一个没有这种<strong>先验知识的SJF、STCP?</strong></p>
<h2 id="调度-多级反馈队列-MLFQ"><a href="#调度-多级反馈队列-MLFQ" class="headerlink" title="调度:多级反馈队列(MLFQ)"></a>调度:多级反馈队列(MLFQ)</h2><p><strong>多级反馈队列(Multi-level Feedback Queue,MLFQ)</strong></p>
<p>多级反馈队列解决两方面的问题：</p>
<ol>
<li>优化周转时间，因为操作系统并不知道工作要运行多久，而工作时间是算法所必须的</li>
<li>多级反馈队列希望给交互用户很好的交互体验，需要降低响应时间。</li>
</ol>
<p><strong>主要问题:通常我们对进程一无所知，应该如何构建调度程序来实现这些目标?调度程序如何在运行过程中学习进程的特征，从而做出更好的调度决策?</strong></p>
<blockquote>
<p>没有完备的知识如何调度?</p>
<p>没有工作长度的先验(priori)知识，如何设计一个能同时减少响应时间和周转时间的调度程序?</p>
</blockquote>
<blockquote>
<p>多级反馈队列是用历史经验预测未来的一个典型的例子，操作系统中有很多地方采用了这种技术（同样存在于计算机科学领域的很多其他地方，比如硬件的分支预测及缓存算法）。如果工作有明显的阶段性行为，因此可以预测，那么这种方式会很有效。当然，必须十分小心地使用这种技术，因为它可能出错，让系统做出比一无所知的时候更糟的决定。</p>
</blockquote>
<h3 id="MLFQ-基本规则"><a href="#MLFQ-基本规则" class="headerlink" title="MLFQ:基本规则"></a>MLFQ:基本规则</h3><p>MLFQ中有&#x3D;&#x3D;许多&#x3D;&#x3D;独立的队列(queue),每个队列有不同的优先级(priority level)。如何时刻，<strong>一个工作只能存在在一个队列</strong>中。MLFQ总是优先执行较高优先级的工作(即在较高级队列中的工作)。<strong>每个队列中可能会有多个工作，因此具有同样的优先级</strong>。</p>
<p><img src="https://s2.loli.net/2023/07/22/nimUqlTZ2NwXuLe.png" alt="MLFQ.png"></p>
<p><strong>关键:设置优先级</strong>。MLFQ根据观察到的行为调整它的优先级。如:工作不断放弃CPU 去等待键盘输入，这是交互型进程的可能行为，因此会让它保持高优先级。相反，如果一个工作长时间地占用 CPU，会降低其优先级。</p>
<p>基本规则:</p>
<ul>
<li><strong>规则1</strong>:如果A的优先级&gt;B的优先级：运行A</li>
<li><strong>规则2</strong>:如果A的优先级 &#x3D; B的优先级，<strong>轮转运行A和B</strong></li>
</ul>
<h3 id="尝试1-如何改变优先级"><a href="#尝试1-如何改变优先级" class="headerlink" title="尝试1:如何改变优先级"></a>尝试1:如何改变优先级</h3><p>第一次尝试优先级调整算法:</p>
<ul>
<li><p><strong>规则3</strong>: 工作进入系统时，放在最高优先级(最上层队列)</p>
</li>
<li><p>**规则4a:**工作用完整个时间片后，降低其优先级(移入下一个队列)</p>
</li>
<li><p><strong>规则4b</strong>:如果工作在其时间片以内主动释放CPU，则优先级不变</p>
</li>
</ul>
<h4 id="实例1-单个长工作"><a href="#实例1-单个长工作" class="headerlink" title="实例1:单个长工作"></a>实例1:单个长工作</h4><p><img src="https://s2.loli.net/2023/07/22/9npbumC5SZshKgA.png" alt="MLFG-priority-short job.png"></p>
<p>该工作首先首先进入最高优先级Q2,执行一个10ms的时间片后，优先级减1，进入Q1。执行一个时间片hou，进入最低优先级Q0。之后一直在Q0停留</p>
<h4 id="实例2-短工作"><a href="#实例2-短工作" class="headerlink" title="实例2:短工作"></a>实例2:短工作</h4><p><img src="https://s2.loli.net/2023/07/22/9npbumC5SZshKgA.png" alt="MLFG-priority-short job.png"></p>
<p>A是一个长时间运行的CPU密集型工作，B是一个运行时间很短的交互型工作。假设A执行一段时间后B到达。对B来说MLFQ近似SJF。</p>
<p>主要目标:如果不知道工作是短工作还是长工作，那么就在开始的时候假设其是短工作，并赋予最高优先级。如果确实是短工作，则很快会执行完毕，否则将被慢慢移入低优先级队列，而这时该工作也被认为是长工作了。通过这种方式，MLFQ 近似于 SJF。</p>
<h4 id="实例3-有I-x2F-O"><a href="#实例3-有I-x2F-O" class="headerlink" title="实例3:有I&#x2F;O"></a>实例3:有I&#x2F;O</h4><p><img src="https://s2.loli.net/2023/07/22/lA49fhoGHM3ctTv.png" alt="MLFG-priority-IO.png"></p>
<p>根据4b规则,如果进程在时间片用完之前主动放弃CPU，则优先级不变。假设交互型工作中有大量的 I&#x2F;O 操作（比如等待用户的键盘或鼠标输入），它会在时间片用完之前放弃 CPU。在这种情况下，我们不想处罚它，只是保持它的优先级不变。</p>
<h4 id="当前MLFQ的一些问题"><a href="#当前MLFQ的一些问题" class="headerlink" title="当前MLFQ的一些问题"></a>当前MLFQ的一些问题</h4><ol>
<li>系统有太多交互型工作，不断占用CPU，导致长工作永远无法得到CPU</li>
<li>用户重写程序，愚弄调度程序(game the scheduler)。愚弄调度程序指的是用一些卑鄙的手段欺骗调度程序，让它给你远超公平的资源。在时间片用完之前，调用I&#x2F;O操作，从而主动释放CPU</li>
<li>一个程序可能在不同时间表现不同。一个计算密集的进程可能在某段时间表现为一个交互型的进程。使用目前的方法，不会享受系统中其他交互型工作的待遇。</li>
</ol>
<h3 id="尝试2-提升优先级"><a href="#尝试2-提升优先级" class="headerlink" title="尝试2:提升优先级"></a>尝试2:提升优先级</h3><p>要让CPU密集型工作也能取得一些进展，我们能做些什么?</p>
<p><strong>周期性地提升(boost)所有工作的优先级。(入将所有工作置为最高优先级队列)</strong></p>
<ul>
<li><strong>规则5</strong>:经过一段时间S，就将系统中所有工作重新加入最高优先级队列.</li>
</ul>
<p>新规则解决的两个问题:</p>
<ol>
<li>进程不会饿死-在最高优先级队列中，它会以轮转的方式，与其他高优先级工作分享CPU，从而最终获取执行。</li>
<li>如果一个CPU密集型工作变成了交互型，当它优先级提升时，调度程序会正确对待它。</li>
</ol>
<p><img src="https://s2.loli.net/2023/07/23/bBfO7H6RENhJSsY.png" alt="MLFQ-priperty-level.png"></p>
<p>没有优先级提升，长工作在两个短工作到达后被饿死。采用优先级提升，每50ms就有一次优先级提升，从而可以定期执行。</p>
<p>S的值如何设置？。**巫毒常量(voo-doo constant):**如果S太高，长工作会饥饿，如果设置得太低，交互型工作又得不到合适的CPU时间比例。</p>
<h3 id="尝试3-更好的计时方式"><a href="#尝试3-更好的计时方式" class="headerlink" title="尝试3:更好的计时方式"></a>尝试3:更好的计时方式</h3><p>如何阻止调度程序被愚弄？</p>
<p>MLFQ的每层队列提供更完善的CPU计时方法(accounting)。调度程序<strong>应该记录一个进程在某一层中消耗的总时间</strong>，而不是调度时重新计时。只要进程用完了自己的配额，就将它降低至低一次优先级队列中去。不论它是一次用完的，还是拆层很多次用完。</p>
<ul>
<li>**规则4:**一旦工作用完了其在某一层中的时间配额(无论中间放弃了多少次CPU)，就减低其优先级(移入低一级队列)</li>
</ul>
<p><img src="https://s2.loli.net/2023/07/23/ihNFWonmw6O1DAl.png" alt="MLFQ-priperty-change.png"></p>
<p>进程可以在每个时间片结束前发起一次I&#x2F;O操作，从而垄断CPU时间。有了保护后，不论进程的I&#x2F;O行为如何，都会慢慢降低优先级，因而无法获得超过公平的CPU时间比例</p>
<h3 id="MLFQ调度及其他问题"><a href="#MLFQ调度及其他问题" class="headerlink" title="MLFQ调度及其他问题"></a>MLFQ调度及其他问题</h3><p><strong>如何配置一个调度程序</strong>:配置多少队列?每一层队列的时间片配置多大?为了避免饥饿问题以及进程行为改变，应该多久提升一次进程的优先级?</p>
<p>如:大多数的MLFQ变体头支持不同队列可变的时间片长度。&#x3D;&#x3D;高优先级队列&#x3D;&#x3D;通常只有较短的时间片,因而这一层的交互工作可以更快地切换。&#x3D;&#x3D;低优先级队列&#x3D;&#x3D;中更多的是CPU密集型工作，配置更长的时间片会取得更好的效果。</p>
<blockquote>
<p><strong>避免巫毒常量(Ousterhout定律)</strong></p>
<p>尽可能避免巫毒常量是个好主意。然而，从上面的例子可以看出，这通常很难。当然，我们也可以让系统自己去学习一个很优化的值，但这同样也不容易。因此，通常我们会有一个写满各种参数值默认值的配置文件，使得系统管理员可以方便地进行修改调整。然而，大多数使用者并不会去修改这些默认值，这时就寄希望于默认值合适了。这个提示是由资深的 OS 教授 John Ousterhout 提出的，因此称为Ousterhout 定律（Ousterhout’s Law）。</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/23/owixGS17vLspd8Z.png" alt="MLFQ-queue.png"></p>
<p>许多调度程序有我们没有提到的特征。如：有些调度程序将最高优先级列留给操作系统使用，因此用户工作无法得到系统的最高优先级。有些系统允许用户给出优先级设置的建议（advice），比如通过命令行工具 nice，可以增加或降低工作的优先级（稍微），从而增加或降低它在某个时刻运行的机会。更多信息请查看 man 手册。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>MLFQ规则:</p>
<ul>
<li>规则1:如果A的优先级&gt;B的优先级，运行A</li>
<li>规则2:如果A的优先级 &#x3D; B的优先级，轮转运行A和B</li>
<li>规则3:工作进入系统时，放在最高优先级</li>
<li>规则4:一旦工作用完了其在某一层中的时间配额(无论中间主动放弃了多少次CPU)，降低其优先级</li>
<li>规则5:经过一段时间S，就将系统中所有工作重新加入最高优先级队列</li>
</ul>
<h2 id="调度-比额份额"><a href="#调度-比额份额" class="headerlink" title="调度:比额份额"></a>调度:比额份额</h2><p><strong>比例份额(proportional-share)调度程序</strong>，有时也称为公平份额(fair-share)调度程序。&#x3D;&#x3D;调度程序的最终目标，是确保每个工作获得一定比例的CPU时间，而不是优化周转时间和响应时间。&#x3D;&#x3D;</p>
<blockquote>
<p><strong>如何按比例分配CPU？</strong></p>
<p>如何设计调度程序来按比例分配CPU？其关键的机制是什么？效率如何？</p>
</blockquote>
<h3 id="基本概念-彩票表示份额"><a href="#基本概念-彩票表示份额" class="headerlink" title="基本概念:彩票表示份额"></a>基本概念:彩票表示份额</h3><p>彩票数（ticket）代表了进程（或用户或其他）占有某个资源的份额。一个进程拥有的彩票数占总彩票数的百分比，就是它占有资源的份额。</p>
<blockquote>
<p><strong>利用随机性</strong></p>
<ol>
<li>随机方法常常可以避免奇怪的边角情况。较传统的算法可能在处理这些情况时遇到麻烦</li>
<li>随机方法很轻量，几乎不需要记录任何状态。(获取CPU时间)</li>
<li>随机方法很快。只要能快速地产生随机数，做出决策就很快。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>用彩票来表示份额</strong></p>
<p>彩票（步长）调度的设计中，最强大（且最基本）的机制是彩票。在这些例子中，彩票用于表示一个进程占有 CPU 的份额，但也可以用在更多的地方。比如在虚拟机管理程序的虚存管理的最新研究工作中，Waldspurger 提出了用彩票来表示用户占用操作系统内存份额的方法[W02]。因此，如果你需要通过什么机制来表示所有权比例，这个概念可能就是彩票。</p>
</blockquote>
<h3 id="彩票机制"><a href="#彩票机制" class="headerlink" title="彩票机制"></a>彩票机制</h3><p>彩票调度还提供了一些机制，以不同且有效的方式来调度彩票。</p>
<ul>
<li>利用<strong>彩票货币</strong>(ticket currency):这种方式允许拥有一组彩票的用户以他们喜欢的某种货币，将彩票分给自己的不同工作，之后操作系统再自动将这种货币兑换为全局彩票。</li>
<li><strong>彩票转让</strong>(ticket transfer):通过转让，一个进程可以&#x3D;&#x3D;临时&#x3D;&#x3D;地将自己的彩票交给另一个进程。这种机制在客户端&#x2F;服务端交互的场景种尤其有用，在这种场景中，客户端进程向服务端发送消息，请求其按自己的需求执行工作，为了加速服务端的执行，客户端可以将自己的彩票&#x3D;&#x3D;转让&#x3D;&#x3D;给服务端，从而尽可能加速服务端执行自己请求的速度。服务端执行结束后会将这部分彩票&#x3D;&#x3D;归还&#x3D;&#x3D;给客户端。</li>
<li><strong>彩票通胀</strong>(ticket inflation)有时也很有用。利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。当然在竞争环境中，进程之间互相不信任，这种机制就没什么意义。一个贪婪的进程可能给自己非常多的彩票，从而接管机器。但是，通胀可以用于进程之间相互信任的环境。在这种情况下，如果一个进程知道它需要更多 CPU 时间，就可以增加自己的彩票，从而将自己的需求告知操作系统，这一切不需要与任何其他进程通信。</li>
</ul>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>一个随机数生成器来选择中奖彩票和一个记录系统种所有进程的数据结构，以及彩票的总数。</p>
<p><img src="https://s2.loli.net/2023/07/23/nCouhdDlH5mvciA.png" alt="ticket-implement.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//counter: used to track if we&#x27;ve found the winner yet</span></span><br><span class="line"><span class="type">int</span> counter - <span class="number">0</span>;</span><br><span class="line"><span class="comment">// winner: use some call to a random number generator to </span></span><br><span class="line"><span class="comment">// get a value, between 0 and the total # of tickets</span></span><br><span class="line"><span class="type">int</span> winner = getrandom(<span class="number">0</span>,totaltickets);</span><br><span class="line"><span class="comment">// current: use this to walk through the list of jobs</span></span><br><span class="line"><span class="type">node_t</span>* current = head;</span><br><span class="line"><span class="comment">// loop until the sum of ticket values is &gt; the winner</span></span><br><span class="line"><span class="keyword">while</span>(current)&#123;</span><br><span class="line">    counter = counter + current-&gt;tickets;</span><br><span class="line">    <span class="keyword">if</span>(counter &gt; winner)</span><br><span class="line">        <span class="keyword">break</span>;	<span class="comment">//found </span></span><br><span class="line">    current = current -&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// &#x27;current&#x27; is the winner: schedule it...</span></span><br></pre></td></tr></table></figure>

<p>要让这个过程更有效率,建议将列表项按照彩票数<strong>递减</strong>排序。这个顺序并不会影响算法的正确性，但能保证用最小的迭代次数找到需要的节点，尤其是大多数彩票被少数进程拥有。</p>
<h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><p>研究一下两个互相竞争工作的完成时间，每个工作都有相同数目的 100 张彩票，以及相同的运行时间 <em>R</em>。在这种情况下，我们希望两个工作在大约同时完成，但由于随机性，有时一个会先于另一个完成。</p>
<p>为了量化这种区别，我们定义了一个简单的不公平指标 <em>U</em>（unfairness metric），将两个工作完成时刻相除得到 <em>U</em> 的值。</p>
<p><img src="https://s2.loli.net/2023/07/23/2Ew6pkfQVxNqJ3D.png" alt="unfairness metric.png"></p>
<p>在工作执行时间很短时，平均不公平非常糟糕。</p>
<h3 id="如何分配彩票"><a href="#如何分配彩票" class="headerlink" title="如何分配彩票"></a>如何分配彩票</h3><p>这是一个非常棘手的问题，系统的运行严重依赖于彩票的分配。假设用户自己知道如何分配，因此可以给每个用户一定量的彩票，由用户按照需要自主分配给自己的工作。</p>
<h3 id="为什么不是确定的"><a href="#为什么不是确定的" class="headerlink" title="为什么不是确定的"></a>为什么不是确定的</h3><p>虽然随机方式可以使得调度程序的实现简单，但偶尔并不能产生正确的比例，尤其在工作时间很短的情况下。</p>
<p><strong>步长调度(stride scheduling)</strong>:系统中的每个工作都有自己的步长，这个值与票数值成反比。</p>
<p>A、B、C 这 3 个工作的票数分别是 100、50 和 250，我们通过用一个大数分别除以他们的票数来获得每个进程的步长。比如用 10000 除以这些票数值，得到了 3 个进程的步长分别为 100、200 和 40。我们称这个值为每个进程的步长（stride）。每次进程运行后，我们会让它的计数器 [称为行程（pass）值] 增加它的步长，记录它的总体进展。</p>
<p>之后，调度程序使用进程的步长及行程值来确定调度哪个进程。<strong>基本思路</strong>很简单：当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行之后将该进程的行程值增加一个步长。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">current = remove_min(<span class="built_in">queue</span>);</span><br><span class="line">schedule(current);</span><br><span class="line">current-&gt;pass +=current-&gt;stride;</span><br><span class="line">insert(<span class="built_in">queue</span>,current);</span><br></pre></td></tr></table></figure>

<p>在我们的例子中，3 个进程（A、B、C）的步长值分别为 100、200 和 40，初始行程值都为 0。因此，最初，所有进程都可能被选择执行。假设选择 A（任意的，所有具有同样低的行程值的进程，都可能被选中）。A 执行一个时间片后，更新它的行程值为 100。然后运行 B，并更新其行程值为 200。最后执行 C，C 的行程值变为 40。这时，算法选择最小的行程值，是 C，执行并增加为 80（C 的步长是 40）。然后 C 再次运行（依然行程值最小），行程值增加到 120。现在运行 A，更新它的行程值为 200（现在与 B 相同）。然后 C 再次连续运行两次，行程值也变为 200。此时，所有行程值再次相等，这个过程会无限地重复下去。</p>
<p><img src="https://s2.loli.net/2023/07/23/AbT9ukU8fdXKezn.png" alt="stride scheduling.png"></p>
<p><strong>可以看出，C 运行了 5 次、A 运行了 2 次，B 一次，正好是票数的比例——200、100 和 50。彩票调度算法只能一段时间后，在概率上实现比例，而步长调度算法可以在每个调度周期后做到完全正确。</strong></p>
<p>既然步长调度可以精确控制，为什么还要彩票调度算法:</p>
<p>&#x3D;&#x3D;彩票算法步需要全局状态&#x3D;&#x3D;，如果一个新的进程在上面的步长调度时加入系统，应该怎么设置它的行程值?而彩票调度算法不需要对每个进程记录全局状态，只需要用新进程的票数更新全局的总票数就可以了。因此彩票调度算法能够更合理地处理新加入的进程。</p>
<h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><ul>
<li><p>步长和彩票都不能很好地适合I&#x2F;O</p>
</li>
<li><p>票数分配问题并没有确定的解决方式</p>
</li>
</ul>
<h2 id="多处理器调度-高级"><a href="#多处理器调度-高级" class="headerlink" title="多处理器调度(高级)"></a>多处理器调度(高级)</h2><p><strong>多处理器调度(multiprocessor scheduling)</strong></p>
<p>多核CPU带来了许多<strong>困难</strong>:主要困难是典型的应用程序都只使用一个CPU，增加了更多的CPU并没有让这类程序运行得更快。</p>
<p>为了解决这个问题，不得不重写这些应用程序，使之能并行(parallel)执行，也许使用多线程。</p>
<blockquote>
<p><strong>高级章节</strong></p>
<p>需要阅读本书的更多内容才能真正理解高级章节，但这些内容在逻辑上放在一章里。例如，本章是关于多处理器调度的，如果先学习了中间部分的并发知识，会更有意思。但是，从逻辑上它属于本书中虚拟化（一般）和 CPU 调度（具体）的部分。因此，建议不按顺序学习这些高级章节。</p>
</blockquote>
<p>新的问题:多处理器调度(multiprocessor scheduling)。</p>
<blockquote>
<p><strong>如何在多处理器上调度工作</strong></p>
<p>操作系统应该如何在多 CPU 上调度工作？会遇到什么新问题？已有的技术依旧适用吗？是否需要新的思路？</p>
</blockquote>
<h3 id="背景-多处理器架构"><a href="#背景-多处理器架构" class="headerlink" title="背景:多处理器架构"></a>背景:多处理器架构</h3><p><strong>多处理器和单CPU的基本区别:</strong></p>
<ul>
<li>对硬件缓存(cache)的使用</li>
<li>多处理器之间共享数据的方式</li>
</ul>
<p>在单CPU系统中，存在多级的硬件缓存(hardware cache)），一般来说会让处理器更快地执行程序。<strong>缓存是很小但很快的存储设备</strong>，通常拥有内存中最热的数据的备份。相比之下，内存很大且拥有所有的数据，但访问速度较慢。通过将频繁访问的数据放在缓存中，系统似乎拥有又大又快的内存。</p>
<p><strong>缓存是基于局部性(locality)的概念</strong>,局部性有两种:</p>
<ul>
<li>时间局部性:当一个数据被访问后，它很有困难会在不久的将来被再次访问。比如循环代码中的数据或指令本身</li>
<li>空间局部性:当程序访问地址为x的数据时，很有可能会紧接着访问x周围的数据。比如遍历数组或指令的顺序执行</li>
</ul>
<p>由于这两种局部性存在于大多数的程序中，硬件系统可以很好地预测哪些数据可以放入缓存，从而运行得更好。</p>
<p><img src="https://s2.loli.net/2023/07/24/2UVPBuafoSCsF3O.png" alt="shared-cpu.png"></p>
<p>多CPU的情况下缓存要复杂得多。</p>
<p><strong>缓存一致性(cache coherence)</strong>:将数据写回内存比较慢，因此系统(通常)会稍后再做。另外的CPU此时读取到的值可能是旧值，导致数据不一致。</p>
<p><strong>解决方法:</strong> &#x3D;&#x3D;硬件通过监控内存访问，硬件可以保证获得正确的数据，并保证共享内存的唯一性&#x3D;&#x3D;。在基于总线的系统中，一种方式是使用总线窥探(bussnooping)。每个缓存都通过监听链接所有缓存和内存的总线，来发现内存访问。如果CPU发现对它放在缓存中的数据的更新，会作废(invalidate)本地副本(从缓存中移除)，或更新(update)它(修改为新值)。回写缓存。</p>
<h3 id="别忘了同步"><a href="#别忘了同步" class="headerlink" title="别忘了同步"></a>别忘了同步</h3><p>缓存做了这么多工作来提供一致性，应用程序(或操作系统)仍需要关心共享数据的访问。</p>
<p>跨CPU访问(特别是写入)共享数据或数据结构时，需要使用互斥原语(比如锁)，才能保证正确性。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	删除共享链表的一个元素:</span></span><br><span class="line"><span class="comment">		假设两个 CPU 上的不同线程同时进入这个函数。如果线程 1 执行第一行，会将 head 的当前值存入它的 tmp 变量。如果线程 2 接着也执行第一行，它也会将同样的 head 值存入它自己的私有 tmp 变量（tmp 在栈上分配，因此每个线程都有自己的私有存储）。因此，两个线程会尝试删除同一个链表头，而不是每个线程移除一个元素，这导致了各种问题（比如在第 4 行重复释放头元素，以及可能两次返回同一个数据）。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">Node_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> __<span class="title">Node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;Node_t;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">List_Pop</span><span class="params">()</span>&#123;</span><br><span class="line">    Node_t *tmp = head;			<span class="comment">//remember old head...</span></span><br><span class="line">    <span class="type">int</span> value = head-&gt;valie;	<span class="comment">//...and its value</span></span><br><span class="line">    head = head-&gt;next;			<span class="comment">//advance head to next pointer</span></span><br><span class="line">    <span class="built_in">free</span>(tmp);					<span class="comment">//free old head</span></span><br><span class="line">    <span class="keyword">return</span> value;				<span class="comment">//return value at head</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解决方法:**加锁(locking)**。这里只需要一个互斥锁(即pthread_mutex_t m;),然后在函数开始时调用lock(&amp;m),结束时调用unlock(&amp;m)，确保代码的执行如预期。</p>
<p>但新的问题:性能降低，访问同步共享的数据结构会变得很慢。</p>
<h3 id="最后一个问题-缓存亲和度"><a href="#最后一个问题-缓存亲和度" class="headerlink" title="最后一个问题:缓存亲和度"></a>最后一个问题:缓存亲和度</h3><p><strong>缓存亲和度(cache affinity):一个进程在某个CPU上运行时，会在该CPU的缓存中维护许多状态。下次该进程在相同CPU上运行时，由于缓存中的数据而执行得更快。</strong></p>
<p>相反，在不同的CPU上执行，会由于需要重新加载数据而很慢(好在硬件保证的缓存一致性可以保证正确执行)。因此多处理器调度应该尽可能将进程保持在同一个CPU上。</p>
<h3 id="单队列调度"><a href="#单队列调度" class="headerlink" title="单队列调度"></a>单队列调度</h3><p><strong>单队列多处理器调度(Single Queue Multiprocessor Scheduling,SQMS):简单地复用单处理器调度的基本架构，将所有需要调度的工作放入一个单独的队列中。</strong><br><strong>优点</strong>:它不需要太多修改，就可以将原有的策略用于多个 CPU，选择最适合的工作来运行<br><strong>缺点</strong>:</p>
<ol>
<li>缺乏可扩展性(scalability):为了保证在多CPU上正常运行，调度程序的开发者需要在代码中通过加锁(locking)来保证原子性。</li>
<li>缓存亲和性(cache affinity):</li>
</ol>
<p>一个调度队列是顺序如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-&gt;A-&gt;B-&gt;C-&gt;D-&gt;E-&gt;<span class="literal">NULL</span></span><br></pre></td></tr></table></figure>

<p>每个CPU可能的调度序列:</p>
<p><img src="https://s2.loli.net/2023/07/24/rNldeBtp4q1Gw8s.png" alt="non-cache-affinity-cpu.png"></p>
<p>由于每个CPU都简单地从全局共享的队列中选取下一个工作执行，因此每个工作都不断在不同CPU之间转移，与缓存亲和的目标背道而驰。</p>
<p>为了解决这个问题，大多数SQMS调度程序都引入了一些亲和度机制，尽可能让进程在同一个CPU上运行。</p>
<p><img src="https://s2.loli.net/2023/07/24/T6PA3bGZlxUInQo.png" alt="cache-affinity.png"></p>
<p>这种调度中，A、B、C、D的工作都保持在同一个CPU上，只要E不断地来回迂移(migrating),从而尽可能多地获取缓存亲和度。</p>
<h3 id="多队列调度"><a href="#多队列调度" class="headerlink" title="多队列调度"></a>多队列调度</h3><p><strong>多队列多处理器调度(Multi-Queue Multiprocessor Scheduling,MQMS)</strong>:每个CPU一个队列</p>
<p>在 MQMS 中，基本调度框架包含<strong>多个调度队列</strong>，每个队列可以使用<strong>不同的调度规则</strong>，比如轮转或其他任何可能的算法。当一个工作进入系统后，<strong>系统会依照一些启发性规则（如随机或选择较空的队列）将其放入某个调度队列</strong>。这样一来，每个 CPU 调度之间相互独立，就避免了单队列的方式中由于数据共享及同步带来的问题。</p>
<p>假设系统中有两个CPU。这是一些工作进入系统:A、B、C和D。由于每个CPU都有自己的调度队列，操作系统需要决定每个工作放入哪个队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q1-&gt;A-&gt;C		Q2-&gt;B-&gt;D</span><br></pre></td></tr></table></figure>

<p>根据不同队列的调度策略，每个CPU从两个工作中选择，决定谁将运行。可能如下</p>
<p><img src="https://s2.loli.net/2023/07/24/hpEHUA986PX2nwa.png" alt="MQMS.png"></p>
<p>MQMS优点:</p>
<ol>
<li>更具有扩展性:队列的数量会随着CPU的增加而增加，因此锁和缓存争用的开销减低很多。</li>
<li>MQMS天生具有良好的缓存亲和度。所有工作都保持在固定的CPU上，因而可以很好地利用缓存数据。</li>
</ol>
<p>MQMS缺点:</p>
<ol>
<li>负载不均(load imbalance):不同的资源或任务分布不均匀，导致系统中的某些组件负载过重，而其他组件负载较轻的情况。</li>
</ol>
<p><img src="https://s2.loli.net/2023/07/24/jkc5nDEgWBIl6Oo.png" alt="MQMS-load imbalance.png"></p>
<p><img src="https://s2.loli.net/2023/07/24/NyswqUR2fuFzDi3.png" alt="MQMS-load imbalance2.png"></p>
<blockquote>
<p><strong>如何应对负载不均</strong></p>
<p>多队列多处理器调度程序应该如何处理负载不均问题，从而更好地实现预期的调度目标。</p>
</blockquote>
<p><strong>迁移(migration):工作移动，通过工作的跨CPU迁移，实现负载均很</strong></p>
<p>简单的迁移:操作系统将B或Q迁移到CPU1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q1-&gt;			Q2-&gt;B-&gt;D</span><br></pre></td></tr></table></figure>

<p>复杂的迁移:A独自再CPU1上，B和D在CPU2上(单次迁移无法解决)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Q1-&gt;A			Q2-&gt;B-&gt;D</span><br></pre></td></tr></table></figure>

<p><strong>不断地迁移一个或多个工作。</strong>一种解决方式是:不断切换工作</p>
<p><img src="https://s2.loli.net/2023/07/24/Rzt4Na3ycSQ5T9e.png" alt="MQMS-load balance.png"></p>
<p><strong>系统如何决定发起这样的迁移?</strong></p>
<p>&#x3D;&#x3D;工作窃取(work stealing)：&#x3D;&#x3D;工作量较少的队列不定期地”偷看”其他队列是不是比自己的工作多。如果目标队列比源队列更满，就从目标队列”窃取”一个或多个工作，实现负载均衡</p>
<p><strong>频繁地检测其他队列，会带来较高的开销，可扩展性不好。宇多队列调度的目的相反。检测太长，会带来负载不均</strong></p>
<h3 id="Linux多处理器调度"><a href="#Linux多处理器调度" class="headerlink" title="Linux多处理器调度"></a>Linux多处理器调度</h3><p>Linux的3种不同的调度程序:O(1)调度程序、完全公平调度程序(CFS，Completely Fair Scheduler)以及BF调度程序(BFS，Best Fit Scheduling)。</p>
<p>O(1)、CFS采用多队列，BFS采用单队列。两种方法都可以成功。</p>
<p>O(1)调度程序是基于优先级的（类似于之前介绍的 MLFQ）,随时间推移改变进程的优先级，然后调度最高优先级进程，来实现各种调度目标。交互性得到了特别关注。与之不同，CFS 是确定的比例调度方法（类似之前介绍的步长调度）。BFS作为三个算法中唯一采用单队列的算法，也基于比例调度，但采用了更复杂的方案，称为最早最合适虚拟截止时间优先算法（EEVEF）</p>
<h2 id="关于CPU虚拟化的总结"><a href="#关于CPU虚拟化的总结" class="headerlink" title="关于CPU虚拟化的总结"></a>关于CPU虚拟化的总结</h2><p>机制(mechanism):陷阱、陷阱处理程序、时钟中断、操作系统和硬件在进程间切换时如何保持和恢复状态.</p>
<h2 id="关于内存虚拟化的对话"><a href="#关于内存虚拟化的对话" class="headerlink" title="关于内存虚拟化的对话"></a>关于内存虚拟化的对话</h2><p>基址&#x2F;界限技术、TLB和多级页表。虚拟地址(every address generated by a user program is a virtual address)。隔离(isolation)、保护(protection)、</p>
<h2 id="抽象-地址空间"><a href="#抽象-地址空间" class="headerlink" title="抽象:地址空间"></a>抽象:地址空间</h2><p>早期，构造计算机操作系统非常简单。因为用户对操作系统的期望不高。后续更新的“易于使用”“高性能”“可靠性”等，增加了操作系统的难度。</p>
<p><img src="https://s2.loli.net/2023/07/26/98OTsqLaIbpAKW5.png" alt="virtual addressing.png"></p>
<h3 id="早期系统"><a href="#早期系统" class="headerlink" title="早期系统"></a>早期系统</h3><p>操作系统曾经是一组函数（实际上是一个库），在内存中（在本例中，从物理地址 0 开始），然后有一个正在运行的程序（进程），目前在物理内存中（在本例中，从物理地址 64KB 开始），并使用剩余的内存。</p>
<p><img src="https://s2.loli.net/2023/07/24/lgCnpFrdIWARuN6.png" alt="aged-OS.png"></p>
<h3 id="多道程序和时分共享"><a href="#多道程序和时分共享" class="headerlink" title="多道程序和时分共享"></a>多道程序和时分共享</h3><p>多道程序(multiprogramming):其中多个进程在给定时间准备运行，比如当又一个进程在等待I&#x2F;O操作时，操作系统会切换这些进程，增加了CPU的有效利用率(utilization)。</p>
<p>种实现时分共享的方法，是让一<strong>个进程单独占用全部内存运行一小段时间</strong>，然后停止它，并将它所有的状态信息保存在<strong>磁盘</strong>上，加载其他进程的状态信息，再运行一段时间。</p>
<p>这种方法的主要问题:<strong>太慢</strong>。特别是当内存增长的时候。虽然保持和恢复寄存器级的状态信息相对较快，但将全部的内存信息保存在磁盘中太慢了。因此，在进程切换的时候，我们仍然将进程信息放在内存中，这样操作系统可以更有效率地实现时分共享。</p>
<p><img src="https://s2.loli.net/2023/07/24/9wdcxZ8PsNH4W23.png" alt="shared-memory.png"></p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>操作系统需要提供一个易用(easy to use)的物理内存抽象，这个抽象叫作&#x3D;&#x3D;地址空间(address space)&#x3D;&#x3D;，是运行的程序看到的系统中的内存。</p>
<p>一个进程的地址空间包含运行的程序的所有内存状态。</p>
<p>假设地址空间中只有3个部分:</p>
<ul>
<li>代码</li>
<li>栈</li>
<li>堆</li>
</ul>
<p><img src="https://s2.loli.net/2023/07/24/WJonbapIYxVUcwR.png" alt="address space.png"></p>
<p>描述地址空间，是操作系统给与的抽象，而不是物理地址空间的0~16K</p>
<blockquote>
<p><strong>如何虚拟化内存</strong></p>
<p>操作系统如何在单一的物理内存上位多个运行的进程(所有进程共享内存)构建一个私有的、可能很大的地址空间的抽象？</p>
</blockquote>
<p>当操作系统这样做时，我们说操作系统在虚拟化内存(virtualizing memory)。因为运行的程序认为它被加载到特定地址（例如 0）的内存中，并且具有非常大的地址空间。</p>
<p>当进程尝试在地址0执行加载操作时，并不是在物理地址0上执行加载，而是通过一种映射的方式，加载了物理地址所在的位置。</p>
<blockquote>
<p><strong>隔离原则</strong></p>
<p>隔离是建立可靠系统的关键原则。如果两个实体相互隔离，这意味着一个实体的失败不会影响另一个实体。操作系统力求让进程彼此隔离，从而防止相互造成伤害。通过内存隔离，操作系统进一步确保运行程序不会影响底层操作系统的操作。一些现代操作系统通过将某些部分与操作系统的其他部分分离，实现进一步的隔离。</p>
</blockquote>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p><strong>透明(transparency</strong></p>
<p>虚拟内存(VM)系统的一个主要目标是**透明(transparency)**。操作系统实现虚拟内存的方式，应该让运行的程序看不到。因此，程序不应该感知内存被虚拟化的事实。相反，程序的行为就好像它拥有自己的私有物理内存。</p>
<p><strong>效率(efficiency)</strong></p>
<p>操作系统应该追求虚拟化尽可能高效，包括在时间和空间上。实现高效率虚拟化时，<strong>操作系统将不得不依赖硬件支持</strong>。</p>
<p><strong>保护(protection)</strong></p>
<p>操作系统应确保进程受到保护(protect)，不会受其他进程影响，操作系统本身也不会搜进程影响。当一个进程执行加载、存储或指令提取时，<strong>它不应该以任何方式访问或影响其他进程或操作系统本身的内存内容</strong>。因此，保护让我们能在进程间提供隔离(isolation)的特性，每个进程都应该在自己的独立环境中运行，避免其他出错或恶意进程的影响。</p>
<blockquote>
<p><strong>你看到的所有地址都不是真的</strong></p>
<p>作为用户级程序的程序员，可以看到的任何地址都是虚拟地址。只有操作系统，通过精妙的虚拟化内存技术，知道这些指令和数据所在的物理内存的位置。如果你在一个程序中打印出一个地址，那就是一个虚拟的地址。虚拟地址只是提供地址如何在内存中分布的假象，只有操作系统（和硬件）才知道物理地址</p>
</blockquote>
<p>虚拟化内存所需的基本机制(mechanism)，包括硬件和操作系统的支持。我们还将研究一些较相关的策略（policy），你会在操作系统中遇到它们，包括如何管理可用空间，以及在空间不足时哪些页面该释放。</p>
<h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><p>虚拟内存系统负责为程序提供一个巨大的、稀疏的、私有的地址空间的假象，其中保存了程序的私有指令和数据。操作系统在专门硬件的帮助下，通过每一个虚拟内存的索引，将其转换为物理地址，物理内存根据获得的物理地址但获取所需的信息。操作系统会同时对许多进程执行此操作，并且确保程序之间互相不会受到影响，也不会影响操作系统。</p>
<h2 id="插叙-内存操作API"><a href="#插叙-内存操作API" class="headerlink" title="插叙:内存操作API"></a>插叙:内存操作API</h2><blockquote>
<p><strong>如何分配和管理内存</strong></p>
<p>通常使用哪些接口？哪些错误需要避免?</p>
</blockquote>
<h3 id="内存类型"><a href="#内存类型" class="headerlink" title="内存类型"></a>内存类型</h3><p>一个程序会分配两种类型的内存:</p>
<ul>
<li><p>栈内存:它的申请和释放操作是编译器来隐式管理的(automatic内存)</p>
</li>
<li><p>堆内存:所有的申请和释放操作都由程序员显式完成。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;	<span class="comment">//on the stack</span></span><br><span class="line">	<span class="type">int</span> *y = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">//on heap</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器看到指针的声明(int *x)时，知道为一个整型指针分配空间，随后，当程序调用malloc()时，会在堆上请求整数的空间，函数返回这样一个整数的地址，然后讲其存储在栈中以供程序使用。</p>
<h3 id="malloc-调用"><a href="#malloc-调用" class="headerlink" title="malloc()调用"></a>malloc()调用</h3><p>malloc:传入要申请的堆空间的大小，它成功就返回一个指向新申请空间的指针，失败返回NULL</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">//size_t:表示需要的字节的多少</span></span><br><span class="line"><span class="comment">//size_t不会字节传入数字，而是使用各种函数和宏。</span></span><br><span class="line"><span class="type">double</span> *d  = (<span class="type">double</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line"><span class="comment">//sizeof()被认定为一个操作符，而不是函数调用</span></span><br><span class="line"><span class="type">int</span> *x = <span class="built_in">malloc</span>(<span class="number">10</span>*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(x));	<span class="comment">//4 or 8</span></span><br><span class="line"><span class="type">int</span> x[<span class="number">10</span>];</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="keyword">sizeof</span>(x));	<span class="comment">//40 </span></span><br></pre></td></tr></table></figure>

<p>对string进行申请空间:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span>(<span class="built_in">strlen</span>(s)+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="free-调用"><a href="#free-调用" class="headerlink" title="free()调用"></a>free()调用</h3><p>释放不再使用的堆内存，调用free()</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *x = <span class="built_in">malloc</span>(<span class="number">10</span>* <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">...</span><br><span class="line"><span class="built_in">free</span>(x);</span><br></pre></td></tr></table></figure>

<p>分配区域的大小不会被用户传入，必须由内存分配库本身记录追踪</p>
<h3 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h3><p>malloc()和free()成对出现。</p>
<ul>
<li>忘记分配内存</li>
<li>没有分配足够的内存</li>
<li>忘记初始化分配的内存</li>
<li>忘记释放内存</li>
<li>在用完之前释放内存</li>
<li>反复释放内存</li>
<li>错误调用free()</li>
</ul>
<h3 id="底层操作系统支持"><a href="#底层操作系统支持" class="headerlink" title="底层操作系统支持"></a>底层操作系统支持</h3><p>malloc和free()的库调用，而不是系统调用。malloc管理虚拟地址空间内的空间，但是它本身是建立在一些系统调用之上的，这些系统调用会进入操作系统，来请求更多内存或将一些内存释放回系统。</p>
<p>一个这样的系统调用的brk，它被用来改变程序分段(break)的位置:堆结束的位置。它需要一个参数,从而根据新分段是大于还是小于当前分断,来增加或减少堆的大小。另一个调用sbrk要求传入一个增量，但目的是类似的。</p>
<p>最后，你还可以通过mmap()调用从操作系统获得内存。通过传入正确的参数，mmap()可以在程序中创建一个匿名(anonymous)内存区域——这个区域不与任何特定文件相关联，而是与交换空间(swap space)相关联。</p>
<h3 id="其他调用"><a href="#其他调用" class="headerlink" title="其他调用"></a>其他调用</h3><p>内存分配库还支持一些其他调用。，calloc()分配内存，并在返回之前将其置零。如果你但为内存已归零并忘记自己初始化它，这可以防止出现一些错误。当你为某些东西（比如一个数组）分配空间，然后需要添加一些东西时，例程 realloc()也会很有用：realloc()创建一个新的本大的内存区域，将旧区域复制到其中，并返回新区域的指针。</p>
<h2 id="机制-地址转换"><a href="#机制-地址转换" class="headerlink" title="机制:地址转换"></a>机制:地址转换</h2><p>在实现COU虚拟化时，我们遵循的一般准则被称为受限直接访问(Limited Direct Execution,LDE):让程序运行的大部分指令直接访问硬件，只<strong>在一些关键点由操作系统介入来确保“在正确的时间，地点，做正确的事”</strong>。为了实现高效的虚拟化，操作系统应该尽量让自己运行，同时通过在关键点的及时介入(interposing),来保持对硬件的控制。</p>
<p>实现虚拟内存时，我们将追求类似的战略，在实现<strong>高效和控制</strong>的同时，提供期望的虚拟化。<strong>高效</strong>决定了我们要利用硬件的支持，<strong>控制</strong>意味这操作系统要确保应用程序只能访问它自己的内存空间。<strong>灵活性</strong>，我们希望程序能以任何方式访问它自己的地址空间，从而让系统更容易编程:</p>
<blockquote>
<p><strong>如何高效、灵活地虚拟化内存</strong></p>
<p>如何实现高效的内存虚拟化?如何提供应用程序所需的灵活性?如何保持控制应用程序可访问的内存位置，从而确保应用程序的内存访问受到合理的限制？如何高效地实现？</p>
</blockquote>
<p>**基于硬件的地址转换(hardware-based address translation)**，简称地址转换(address translation)。在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际的位置。</p>
<p>仅仅依靠<strong>硬件</strong>不足以实现虚拟内存，因为它只是提供了底层机制来提高效率。<strong>操作系统</strong>必须在关键的位置介入，设置好硬件，以便完成正确的地址转换。操作系统管理内存，记录被占用和空闲的内存位置，并对其使用进行控制。</p>
<h3 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h3><p>假设用户的地址空间必须连续地放在物理内存中。同时，为了简单，我们假设地址空间不是很大，具体来说，小于物理内存的大小。最后，假设每个地址空间的大小完全一样。</p>
<h3 id="一个例子-1"><a href="#一个例子-1" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">func</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    x = x + <span class="number">3</span>；</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">128: movl 0x0(%ebx), %eax ;load 0+ebx into eax </span></span><br><span class="line"><span class="comment">132: addl $0x03, %eax ;add 3 to eax register </span></span><br><span class="line"><span class="comment">135: movl %eax, 0x0(%ebx) ;store eax back to mem</span></span><br><span class="line"><span class="comment">它假定 x 的地址已经存入寄存器 ebx，之后通过 movl 指令将这个地址的值加载到通用寄存器 eax（长字移动）。下一条指令对 eax 的内容加 3。最后一条指令将 eax 中的值写回到内存的同一位置。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>介入(Interposition)很强大</strong></p>
<p>在虚拟内存中，硬件可以介入道每次内存访问中，将进程提供的虚拟地址转换为数据实际存储的物理地址。良好定义的接口都应该提供功能介入机制，以便增加功能或在其他方面提升系统。</p>
</blockquote>
<p>上述3条指令，从进程的角度来看，发生了以下几次内存访问:</p>
<ul>
<li>从地址128获取指令</li>
<li>指向指令(从地址15KB加载数据)</li>
<li>从地址132获取命令</li>
<li>指向命令(没有内存访问)</li>
<li>从地址135获取指令</li>
<li>指向指令(新值存入地址15KB)</li>
</ul>
<p><img src="https://s2.loli.net/2023/07/26/XI25J39ysuKW6l1.png" alt="address-space.png"></p>
<p>操作系统将地址空间放入物理内存的其他位置，并不一定从地址0开始。</p>
<p>怎样在内存中重定位这个进程，同时对该进程透明(transparent)？怎么样提供一种虚拟地址空间从0开始的假象，而实际上地址空间位于另外某个物理地址?</p>
<h3 id="动态-基于硬件-重定位"><a href="#动态-基于硬件-重定位" class="headerlink" title="动态(基于硬件)重定位"></a>动态(基于硬件)重定位</h3><p>基址加界限机制(base and bound)，也称动态重定位(dynamic relocation)</p>
<p>每个CPU需要两个硬件寄存器:<strong>基址</strong>(base)寄存器和<strong>界限</strong>(bound)寄存器。这两个寄存器能<strong>将地址空间放在内存的任何位置</strong>，同时又能<strong>确保进程只能访问自己的地址空间</strong>。</p>
<p>当程序真正执行时，操作系统会决定其在物理内存中的实际加载地址，并将<strong>起始地址记录在基址寄存器</strong>中.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">physical address = virtual address + base</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>基于软件的重定位</strong></p>
<p>早期，在硬件支持重定位之前，一些系统曾经采用纯软件的重定位方式。基本技术被称为静态重定位（static relocation），其中一个名为加载程序（loader）的软件接手将要运行的可执行程序，将它的地址重写到物理内存中期望的偏移位置。 </p>
<p>例如，程序中有一条指令是从地址 1000 加载到寄存器（即 movl 1000，%eax），当整个程序的地址空间被加载到从 3000（不是程序认为的 0）开始的物理地址中，加载程序会重写指令中的地址（即 movl 4000, %eax），从而完成简单的静态重定位。</p>
<p>然而，静态重定位有许多问题，首先也是最重要的是不提供访问保护，进程中的错误地址可能导致对其他进程或操作系统内存的非法访问，一般来说，需要硬件支持来实现真正的访问保护。静态重定位的另一个缺点是一旦完成，稍后很难将内存空间重定位到其他位置</p>
</blockquote>
<p>虚拟地址解析为物理地址过程:</p>
<ul>
<li>进程中的内存引用都是虚拟地址(virtual address)</li>
<li>硬件将虚拟地址加上基址寄存器中的内容</li>
<li>得到物理地址(physical),再发给内存系统</li>
</ul>
<p>也就是说,硬件取得进程认为它要访问的地址，将它转换成数据实际位于的物理地址。重定位是再运行时发生的，而且可以再进程开始运行后改变其地址空间，故称为<strong>动态重定位(dynamic relocation)</strong></p>
<blockquote>
<p><strong>基于硬件的动态重定位</strong></p>
<p>一个基址寄存器将虚拟地址转换位物理地址（访问，一个界限寄存器保证在进程空间内访问(保护。</p>
</blockquote>
<p>**内存管理单元(Memory Management Unit,MMU):**负责CPU的地址转换部分</p>
<h4 id="转换示例"><a href="#转换示例" class="headerlink" title="转换示例"></a>转换示例</h4><p><img src="https://s2.loli.net/2023/07/26/gUyT4rL9RlksDdm.png" alt="address-change.png"></p>
<p>通过基址加虚拟地址的方式，可以得到物理地址。虚拟地址过大或为负数，导致异常。</p>
<blockquote>
<p><strong>数据结构——空闲列表</strong></p>
<p>操作系统必须记录哪些空闲内存没有使用，以便能够为进程分配内存。很多不同的数据结构可以用于这项任务，其中最简单的（也是我们假定在这里采用的）是空闲列表（free list）。它就是一个列表，记录当前没有使用的物理内存的范围。</p>
</blockquote>
<h3 id="硬件支持-总结"><a href="#硬件支持-总结" class="headerlink" title="硬件支持:总结"></a>硬件支持:总结</h3><p>硬件需要提供一些特殊的指令，用于修改基址寄存器和界限寄存器，运行操作系统在切换进程时进行改变，是<strong>特权(privileged)指令</strong>。</p>
<p>用户程序尝试非法访问内存(越界访问、修改基址和界限寄存器)，CPU应该阻止用户程序的执行，并安排异常处理程序。CPU 还必须提供一种方法，来通知它这些处理程序的位置，因此又需要另一些特权指令。</p>
<h3 id="操作系统的问题"><a href="#操作系统的问题" class="headerlink" title="操作系统的问题"></a><img src="https://s2.loli.net/2023/07/26/HaIEjoZpwtMnldz.png" alt="virtual-address-hardware.png">操作系统的问题</h3><p>在一些关键的时刻，操作系统需要介入，以实现基址和界限方式的虚拟内存。</p>
<p><img src="https://s2.loli.net/2023/07/26/d5e6UKrVYDZ2L9P.png" alt="dynamic-relocation.png"></p>
<ol>
<li>在进程创建时，操作系统为进程的地址空间找到内存空间。从空闲列表中为新地址空间找到位置，并将其标记为已用</li>
<li>在进程终止时，操作系统回收进程的所有内存，将内存返回空闲列表，并清除相关的数据结构</li>
<li>上下文切换时，CPU中的基址和界限寄存器需要进行保存和恢复。放在进程的结构中，如进程结构(process structure)或进程控制块(Process Control Block,PCB)中。</li>
<li>操作系统提供异常处理程序(exception handler)，或一些调用的函数。操作系统在启动是加载这些处理程序。</li>
</ol>
<p><img src="https://s2.loli.net/2023/07/26/1udBCkqa6t2lWPb.png" alt="hardAndOs.png"></p>
<p>地址转换过程完全由硬件处理，没有操作系统的介入。在这个时候，发生时钟中断，操作系统切换到进程 B 运行，它执行了“错误的加载”（对一个非法内存地址），这时操作系统必须介入，终止该进程，清理并释放进程 B 占用的内存，将它从进程表中移除。仍然遵循受限直接访问(limited direct execution)</p>
<h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p>地址转换(address translation)，拓展了受限直接访问的概念。利用地址转换，操作系统可以控制进程的所有内存访问，确保访问在地址空间的界限内。</p>
<p><strong>问题:<strong>进程的栈区和堆区使用不多，造成了大量空间的浪费，这种浪费被称位内部碎片(internal framentation)：</strong>已经分配的内存单元内部有未使用的空间，造成了浪费。因为目前使用的是固定大小的情况</strong></p>
<h2 id="分段"><a href="#分段" class="headerlink" title="分段"></a>分段</h2><p>简单的基址和界限寄存器实现的虚拟内存很浪费。剩余的物理内存无法提供连续区域来放置完整的地址空间，进程便无法运行。</p>
<blockquote>
<p><strong>怎样支持大地址空间</strong></p>
<p>怎样支持大地址空间，同时栈和堆之间（可能）有大量空闲空间？在之前的例子里，地址空间非常小，所以这种浪费并不明显。但设想一个 32 位（4GB）的地址空间，通常的程序只会使用几兆的内存，但需要整个地址空间都放在内存中。</p>
</blockquote>
<h3 id="分段-泛化的基址-x2F-界限"><a href="#分段-泛化的基址-x2F-界限" class="headerlink" title="分段:泛化的基址&#x2F;界限"></a>分段:泛化的基址&#x2F;界限</h3><p>**分段(segmentation):**在MMU中引入不止一个基址和界限寄存器对，而是给地址空间内的每个逻辑段(segment)一对。一个段只是地址空间里的一个连续定长的区域，在典型的地址空间里有 3 个逻辑不同的段：代码、栈和堆。分段的机制使得操作系统能够将不同的段放到不同的物理内存区域，从而避免了虚拟地址空间中的未使用部分占用物理内存</p>
<p><img src="https://s2.loli.net/2023/07/26/tsTIiAGModhRHpf.png" alt="MMU-segmentation.png"></p>
<p>只有已用的内存才在物理内存中分配空间，因此可以容纳巨大的地址空间，其中包含大量未使用的地址空间（有时又称为稀疏地址空间，sparse address spaces）。</p>
<blockquote>
<p><strong>段错误</strong></p>
<p>段错误是指在支持分段的机器上发生了非法的内存访问。</p>
</blockquote>
<h3 id="我们引入哪个段"><a href="#我们引入哪个段" class="headerlink" title="我们引入哪个段"></a>我们引入哪个段</h3><p>硬件在地址转换时使用段寄存器。知道段内的偏移量及地址引用了哪个段?</p>
<p>**显式(explicit)方式:**用虚拟地址的开头几位来标识不同的段。</p>
<p><img src="https://s2.loli.net/2023/07/26/cP74enhd8sJpuow.png" alt="segment.png"></p>
<p>如果前两位是00:代码段的地址，01:堆地址，通知硬件引用哪个段。剩下的12位是段内偏移。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get top 2 bits of 14-bit VA</span></span><br><span class="line">Segment = (VirutalSddress &amp; SEG_MASK) &gt;&gt; SEG_SHIFT</span><br><span class="line"><span class="comment">//now get offset</span></span><br><span class="line">Offset = VirtualAddress &amp; OFFSET_MASK</span><br><span class="line"><span class="keyword">if</span>(Offset &gt;= Bounds[Segment])</span><br><span class="line">    RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    PhysAddr = Base[Segment]+Offset</span><br><span class="line">    Register = AccessMemory(PhysAddr)</span><br></pre></td></tr></table></figure>

<p>在隐式(implicit)方式中，硬件通过地址产生的方式来确定段。</p>
<h3 id="栈怎么办"><a href="#栈怎么办" class="headerlink" title="栈怎么办"></a>栈怎么办</h3><p>栈从高地址向低地址访问，反向增长。</p>
<p>除了基址和界限外，硬件还需要知道段的增长方向。</p>
<p>用一位来标识增长方向</p>
<h3 id="支持共享"><a href="#支持共享" class="headerlink" title="支持共享"></a>支持共享</h3><p>要节省内存，有时候在地址空间之间共享(share)某些内存段是有用的。尤其是代码共享，至今仍在使用。</p>
<p><img src="https://s2.loli.net/2023/07/26/QfvEwul21gpNHU9.png" alt="sharedSegment.png"></p>
<p>为了支持共享，需要一些额外的硬件支持—保护位(protection bit)。每个段增加几位标识程序是否能够读写该段，或执行其中的代码，进程不能修改这些内存。</p>
<h3 id="细粒度与粗粒度的分段"><a href="#细粒度与粗粒度的分段" class="headerlink" title="细粒度与粗粒度的分段"></a>细粒度与粗粒度的分段</h3><p>目前为止，只有很少的几个段的系统，认为这种分段是粗粒度的(coarse-grained)。<strong>因为地址空间分成较大的、粗粒度的块。</strong> <strong>允许将空间划分为大量较小的段，这种称为细粒度(fine-grained)分段</strong></p>
<p>支持许多段需要进一步的硬件支持，并在内存中保存某种段表（segment table）。这种段表通常支持创建非常多的段，因此系统使用段的方式，可以比之前讨论的方式更灵活。</p>
<h3 id="操作系统支持"><a href="#操作系统支持" class="headerlink" title="操作系统支持"></a>操作系统支持</h3><p>系统运行时，地址空间中的不同段被重定位到物理内存中。与我们之前介绍的整个地址空间只有一个基址&#x2F;界限寄存器对的方式相比，大量节省了物理内存。具体来说，栈和堆之间没有使用的区域就不需要再分配物理内存，让我们能将更多地址空间放进物理内存。</p>
<p><strong>分段带来的问题</strong>:</p>
<ol>
<li>正确的保存和恢复上下文</li>
<li>管理物理内存的空闲空间（外部碎片,external fragmentation)</li>
</ol>
<p><img src="https://s2.loli.net/2023/07/26/QArIvpyion5abm1.png" alt="compact.png"></p>
<p><strong>解决外部碎片问题</strong>:</p>
<ol>
<li>紧凑(compact)物理内存，重新安排原有的段。</li>
</ol>
<p>如：操作系统先终止允许的进程，将它们的数据复制到连续的内存区域中去，改变它们的段寄存器中的值，指向新的物理地址，从而得到了足够大的连续空闲空间。这样做，操作系统能让新的内存分配请求成功。但是，内存紧凑成本很高，因为拷贝段是内存密集型的，一般会占用大量的处理器时间。</p>
<ol start="2">
<li>利用空闲列表管理算法，试图保留大的内存块用于分配。</li>
</ol>
<p>例如:最优匹配(best-fit)、最坏匹配(worst-fit)、首次匹配(first-fit)以及伙伴算法(buddy algorithm)。</p>
<blockquote>
<p><strong>如果有一千个解决方案，就没有特别好的</strong></p>
<p>存在如此多不同的算法来尝试减少外部碎片，正说明了解决这个问题没有最好的办法。因此我们满足于找到一个合理的足够好的方案。唯一真正的解决办法就是（我们会在后续章节看到），完全避免这个问题，永远不要分配不同大小的内存块。</p>
</blockquote>
<h2 id="空闲空间管理"><a href="#空闲空间管理" class="headerlink" title="空闲空间管理"></a>空闲空间管理</h2><p>空闲空间管理(free-space management)</p>
<p>管理固定大小的单元简单，大小不同的情况会变得复杂。</p>
<blockquote>
<p><strong>如何管理空闲空间</strong></p>
<p>满足变长的分配请求，应该如何管理空闲空间？什么策略可以让碎片最小化？不同方法的时间和空间如何?</p>
</blockquote>
<h3 id="假设-1"><a href="#假设-1" class="headerlink" title="假设"></a>假设</h3><p>假设内存分配类似malloc()和free()，那如何在只知道一个指针的情况下，释放内存的大小….</p>
<p><strong>内部碎片(internal fragmentation):分配的内存块超出了请求的大小</strong></p>
<p>假设内存一旦被分配给客户，就不可以重定位到其他位置。分配重新所管理的是连续的一块字节区域。</p>
<h3 id="底层机制"><a href="#底层机制" class="headerlink" title="底层机制"></a>底层机制</h3><h4 id="分割与合并"><a href="#分割与合并" class="headerlink" title="分割与合并"></a>分割与合并</h4><p>空闲列表包含一组元素，记录了堆中哪些空间还没有分配。</p>
<p><img src="https://s2.loli.net/2023/07/26/6q9aDCQ5yOMo3KG.png" alt="splitting.png"></p>
<p>大于10字节的分配请求会失败，小于10字节的空间将如何分配?</p>
<p><strong>分割(splitting)</strong>:找到一块可以满足请求的空闲空间，将其分割，第一块返回给用户，第二块留在空闲列表.</p>
<p><strong>合并(coalescing)</strong>:分配程序在释放一块内存时合并空闲空间。</p>
<h4 id="追踪已分配空间的大小"><a href="#追踪已分配空间的大小" class="headerlink" title="追踪已分配空间的大小"></a>追踪已分配空间的大小</h4><p><code>free(void *ptr)</code>没有块大小的参数，大多数分配程序会在头块(header)额外保存一点额外的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">header_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> magic;</span><br><span class="line">&#125;<span class="type">header_t</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>&#123;</span><br><span class="line">	<span class="type">head_t</span> *hptr = (<span class="type">void</span> *)ptr - <span class="keyword">sizeof</span>(<span class="type">header_t</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/26/qGQLdphVK46ISsx.png" alt="free-memory.png"></p>
<p>获得头块的指针后，库可以很容易地确定幻数是否符合预期的值，作为正常性检查（assert（hptr-&gt;magic &#x3D;&#x3D; 1234567）），并简单计算要释放的空间大（即头块的大小加区域长度）。</p>
<p>小但重要的细节：实际释放的是头块大小加上分配给用户的空间的大小。因此，如果用户请求 <em>N</em> 字节的内存，库不是寻找大小为 <em>N</em> 的空闲块，而是寻找<em>N</em> 加上头块大小的空闲块。</p>
<h4 id="嵌入空闲队列"><a href="#嵌入空闲队列" class="headerlink" title="嵌入空闲队列"></a>嵌入空闲队列</h4><p>如何在空闲内存自己内部建立这样的一个列表?</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node_t</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;<span class="type">node_t</span>;</span><br><span class="line"><span class="comment">//初始化堆，并将空闲列表的第一个元素放在该空间中。</span></span><br><span class="line"><span class="type">node_t</span> *head = mmap(<span class="literal">NULL</span>,<span class="number">4096</span>,PROT_READ|PROT_WRITE, MAP_ANON|MAP_PRIVATE, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">head-&gt;size = <span class="number">4096</span> - <span class="keyword">sizeof</span>(<span class="type">node_t</span>);</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//执行这段代码之后，列表的状态是它只有一个条目，记录大小为 4088。</span></span><br></pre></td></tr></table></figure>

<p><img src="https://s2.loli.net/2023/07/26/SqPy7VKRehELAiJ.png" alt="free-memory-malloc.png"></p>
<p>假设有一个 100 字节的内存请求。为了满足这个请求，库首先要找到一个足够大小的块。因为只有一个 4088 字节的块，所以选中这个块。假设记录头块为8字节。对于100字节的请求，库从原有的一个空闲块中分配了108字节，返回指向它的一个指针。</p>
<p>当free空间后，遍历数组检查是否可以合并</p>
<h4 id="让堆增长"><a href="#让堆增长" class="headerlink" title="让堆增长"></a>让堆增长</h4><p>如果堆中的内存空间耗尽：向操作系统申请更大的空间。也就是进行了某种系统调用(大多数UNIX系统中的sbrk)，让堆增长。</p>
<h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><p>理想的分配程序可以同时保证快速和碎片最小化。遗憾的是，由于分配及释放的请求序列是任意的（毕竟，它们由用户程序决定），任何特定的策略在某组不匹配的输入下都会变得非常差。</p>
<h4 id="最优匹配"><a href="#最优匹配" class="headerlink" title="最优匹配"></a>最优匹配</h4><p>最优匹配(best fit)：首先遍历整个空闲列表，找到和请求大小一样或更大的空闲块，然后返回这组候选者中最小的一块。这就是所谓的最优匹配（也可以称为最小匹配）。只需要遍历一次空闲列表，就足以找到正确的块并返回。</p>
<p>思想:选择最接它用户请求大小的块，从而尽量避免空间浪费。然而，这有代价。简单的实现在遍历查找正确的空闲块时，要付出较高的性能代价。</p>
<h4 id="最差匹配"><a href="#最差匹配" class="headerlink" title="最差匹配"></a>最差匹配</h4><p>最差匹配(worst fit):尝试找最大的空闲块，分割并满足用户需求后，将剩余的块（很大）加入空闲列表。</p>
<p>思想：最差匹配尝试在空闲列表中保留较大的块，而不是向最优匹配那样可能剩下很多难以利用的小块。但是，最差匹配同样需要遍历整个空闲列表。更糟糕的是，大多数研究表明它的表现非常差，导致过量的碎片，同时还有很高的开销</p>
<h4 id="首次匹配"><a href="#首次匹配" class="headerlink" title="首次匹配"></a>首次匹配</h4><p>首次匹配(first fit):找到第一个足够大的块，将请求的空间返回给用户。同样，剩余的空闲空间留给后续请求。</p>
<p>思想:速度优势（不需要遍历所有空闲块），但有时会让空闲列表开头的部分有很多小块。</p>
<p>分配程序如何管理空闲空间很重要:</p>
<ol>
<li>基于地址排序(address-based ordering)。通过保存空闲块按内存地址有序，合并操作，从而减少内存碎片</li>
</ol>
<h4 id="下次匹配"><a href="#下次匹配" class="headerlink" title="下次匹配"></a>下次匹配</h4><p>下次匹配(next fit):维护一个指针，指向上异常查找结束的位置。</p>
<p>思想:将对空闲空间的查找操作扩散到整个列表中去，避免对列表开头频繁的分割。这种策略的性能与首次匹配很接它，同样避免了遍历查找</p>
<h3 id="其他方式"><a href="#其他方式" class="headerlink" title="其他方式"></a>其他方式</h3><h4 id="分离空闲列表"><a href="#分离空闲列表" class="headerlink" title="分离空闲列表"></a>分离空闲列表</h4><p>分离空闲列表(segregated list):如果某个应用程序经常申请一种（或几种）大小的内存空间，那就用一个独立的列表，只管理这样大小的对象。其他大小的请求都一给更通用的内存分配程序。</p>
<p>通过拿出一部分内存专门满足某种大小的请求，碎片就不再是问题了。而且，由于没有复杂的列表查找过程，这种特定大小的内存分配和释放都很快</p>
<p>如锁和文件系统inode，进行创建一些对象缓存。</p>
<h2 id="分页-介绍"><a href="#分页-介绍" class="headerlink" title="分页:介绍"></a>分页:介绍</h2><p>操作系统管理空间的两种方法:</p>
<ol>
<li>将空间分割城不同长度的分片。像虚拟内存管理中的分段。</li>
<li>将空间分割成固定长度的分片。在虚拟内存中称为分页。</li>
</ol>
<p>分页不是将一个进程的地址空间分割成几个不同长度的逻辑段（即代码、堆、段），而是分割成固定大小的单元，每个单元称为&#x3D;&#x3D;一页&#x3D;&#x3D;。相应地，我们把物理内存看成是定长槽块的阵列，叫作&#x3D;&#x3D;页帧（page frame）&#x3D;&#x3D;。每个这样的页帧包含一个虚拟内存页。</p>
<blockquote>
<p><strong>如何通过页来实现虚拟内存</strong></p>
<p>如何通过页来实现虚拟内存，从而避免分段的问题？基本技术是什么？如何让这些技术运行良好，并尽可能减少空间和时间开销？</p>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>虚拟地址空间的页放在物理内存的不同位置，操作系统页使用了物理内存。</p>
<p>分页的优先:</p>
<ol>
<li>灵活性：操作系统能够高效地提供地址空间的抽象，不管进程如何使用地址空间。</li>
<li>空闲空间的管理简单。操作系统希望将 64 字节的小地址空间放到 8 页的物理地址空间中，它只要找到 4 个空闲页。也许操作系统保存了一个所有空闲页的空闲列表（free list），只需要从这个列表中拿出 4 个空闲页。</li>
</ol>
<p>&#x3D;&#x3D;页表(page table)&#x3D;&#x3D;:记录地址空间的每个虚拟页放在物理内存中的位置的一个数据结构</p>
<p>上述页表(VP0-&gt;PF3)，(VP1-&gt;PF7)，(VP2-&gt;PF5)，(VP3-&gt;PF2)</p>
<p>**作用:**为地址空间的每个虚拟页面保存地址转换(address translation)，从而让我们知道每个页在物理内存中的位置。</p>
<p><img src="https://s2.loli.net/2023/07/26/CiBS5epv1GgzjFE.png" alt="pageExp.png"></p>
<p><strong>转换(translate)的过程</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">movl &lt;virtual address&gt;, %eax</span><br><span class="line"></span><br><span class="line">movl <span class="number">21</span>, %eax</span><br><span class="line"><span class="comment">//将虚拟地址21变成二进制形式，是010101</span></span><br></pre></td></tr></table></figure>

<p>进程的虚拟地址空间是64字节，我们的虚拟地址总共需要6位。(2^6^&#x3D;64)</p>
<p>虚拟页面号(virtual page number,VPN)和页内的偏移量(offset)。</p>
<p>页面大小是16字节，位于64字节的地址空间，拥有4个页，所以有2位用来标识页面号。</p>
<p><img src="https://s2.loli.net/2023/07/26/5OsqAzGRmkInhKg.png" alt="virtual-page-number.png"></p>
<p>虚拟地址“21”在虚拟页“01”（或 1）的第 5 个（“0101”）字节处。通过虚拟页号，我们现在可以检索页表，找到虚拟页 1 所在的物理页面。在上面的页表中，物理帧号（PFN）（有时也称为物理页号，physical page number 或 PPN）是 7（二进制 111）。因此，我们可以通过用 PFN 替换 VPN 来转换此虚拟地址，然后将载入发送给物理内存</p>
<p><img src="https://s2.loli.net/2023/07/26/mejsu5W4CM6HTfk.png" alt="address translate.png"></p>
<p>最终的物理地址是1110101，正是我们希望加载指令获取数据的地方。</p>
<h3 id="页表存在哪"><a href="#页表存在哪" class="headerlink" title="页表存在哪"></a>页表存在哪</h3><p>如今，页表已经非常大了，64位地址空间的页表。很多操作系统将页表存储再虚拟内存中，也可以再磁盘上。</p>
<h3 id="列表中究竟有什么"><a href="#列表中究竟有什么" class="headerlink" title="列表中究竟有什么"></a>列表中究竟有什么</h3><p>页表是一种数据结构，用于将虚拟地址(虚拟页号）映射到物理地址(物理帧号)</p>
<p>线性页表(linear page table)是数组。操作系统通过虚拟页号（VPN）检索数组，并在该索引处查找页表项（PTE），以便找到期望的物理帧号（PFN）。每个PTE的内容，其中有许多不同的位。</p>
<p><strong>有效位</strong>(valid bit)通常用于指示特定地址转换是否有效。当一个程序开始运行时，它的代码和堆在器地址空间的一端，栈在另一端。所有未使用的中间空间都被标记为无效(invalid)，如果进程尝试访问这种内存，就会陷入操作系统，可能导致进程终止。(有效位用于支持稀疏地址空间</p>
<p><strong>保护位</strong>(protection bit):表明页是否可以读取、写入或执行。</p>
<p><strong>存在位</strong>(present bid):表示该页是物理存储器还是在磁盘上。</p>
<p><strong>脏位</strong>(dirty bit):表明页面被带入内存后是否被修改过。</p>
<p><strong>参考位</strong>(reference bit,也是范文位):用于追踪页是否被范文，页用于确定哪些页很受欢迎，保存在内存中。</p>
<p><img src="https://s2.loli.net/2023/07/27/FhsbtRq84HKLGCx.png" alt="page-table-e.png"></p>
<h3 id="分页-也很慢"><a href="#分页-也很慢" class="headerlink" title="分页:也很慢"></a>分页:也很慢</h3><p>内存中的页表，有可能太大，导致速度变慢。</p>
<p><code>movl 21,%eax</code></p>
<p>页表基址寄存器(page-table base register)包含页表的起始位置的物理地址。为了找到对应的PTE,执行以下功能</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line">PTEAddr = PageTableBaseRegister + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br><span class="line"><span class="comment">// Extract the VPN from the virtual address </span></span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT </span><br><span class="line"><span class="comment">// Form the address of the page-table entry (PTE) </span></span><br><span class="line">PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE)) </span><br><span class="line"><span class="comment">// Fetch the PTE </span></span><br><span class="line">PTE = AccessMemory(PTEAddr) </span><br><span class="line"><span class="comment">// Check if process can access the page </span></span><br><span class="line"><span class="keyword">if</span> (PTE.Valid == False) </span><br><span class="line">RaiseException(SEGMENTATION_FAULT) </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False) </span><br><span class="line">RaiseException(PROTECTION_FAULT) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="comment">// Access is OK: form physical address and fetch it </span></span><br><span class="line">offset = VirtualAddress &amp; OFFSET_MASK </span><br><span class="line">PhysAddr = (PTE.PFN &lt;&lt; PFN_SHIFT) | offset </span><br><span class="line">Register = AccessMemory(PhysAddr)</span><br></pre></td></tr></table></figure>

<p>对于每个内存引用，分页都需要我们执行一个额外的内存引用，以便首先从页表中获取地址转换。</p>
<h3 id="内存追踪"><a href="#内存追踪" class="headerlink" title="内存追踪"></a>内存追踪</h3><p>我们现在准备好跟踪程序的内存引用了。当它运行时，每个获取指将产生两个内存引用：一个访问页表以查找指令所在的物理框架，另一个访问指令本身将其提取到 CPU 进行处理。</p>
<blockquote>
<p><strong>数据结构-页表</strong></p>
<p>现代操作系统的内存管理子系统中最重要的数据结构之一就是页表（page table）。通常，页表存储虚拟—物理地址转换（virtual-to-physical address translation），从而让系统知道地址空间的每个页实际驻留在物理内存中的哪个位置。由于每个地址空间都需要这种转换，因此一般来说，系统中每个进程都有一个页表。页表的确切结构要么由硬件（旧系统）确定，要么由 OS（现代系统）更灵活地管理。</p>
</blockquote>
<h2 id="分页-快速地址转换-TLB"><a href="#分页-快速地址转换-TLB" class="headerlink" title="分页:快速地址转换(TLB)"></a>分页:快速地址转换(TLB)</h2><p>使用分页作为核心机制实现虚拟内存，可能会带来较高的性能开销。因为要使用分页，就要将内存地址空间切分成大量固定大小的单元(页)，并且需要记录这些单元的地址映射信息。</p>
<p>因为这些映射信息一般存储在物理内存中，所以在转换虚拟地址时，分页逻辑上需要一次额外的内存访问。每次指令获取、显式加载或保存，都要额外读一次内存以得到转换信息，这慢得无法接受。</p>
<blockquote>
<p><strong>如何快速地址转换</strong></p>
<p>如何才能加速虚拟地址转换，尽量避免额外的内存访问？需要什么样的硬件支持？操作系统该如何支持？</p>
</blockquote>
<p>地址转换缓冲(address-translation cache，也叫TLB:translation-lookaside buffer,地址转换旁路缓冲存储器)是频繁发生的虚拟到物理地址转换的硬件缓存（cache）。对每次内存访问，硬件先检查TLB，看看其中是否有期望的转换映射，如果有，就完成转换，不用访问页表 。</p>
<h3 id="TLB的基本算法"><a href="#TLB的基本算法" class="headerlink" title="TLB的基本算法"></a>TLB的基本算法</h3><p>假设使用简单的线性页表(linear page table,即页表是一个数组)和硬件管理的TLB(hardware-managed TLB,即硬件承担许多页表访问的责任)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT </span><br><span class="line">(Success, TlbEntry) = TLB_Lookup(VPN) </span><br><span class="line"><span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit </span></span><br><span class="line"><span class="keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True) </span><br><span class="line">Offset = VirtualAddress &amp; OFFSET_MASK </span><br><span class="line">PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset </span><br><span class="line">AccessMemory(PhysAddr) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">RaiseException(PROTECTION_FAULT) </span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB Miss </span></span><br><span class="line">PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE)) </span><br><span class="line">PTE = AccessMemory(PTEAddr) </span><br><span class="line"><span class="keyword">if</span> (PTE.Valid == False) </span><br><span class="line">RaiseException(SEGMENTATION_FAULT) </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False) </span><br><span class="line">RaiseException(PROTECTION_FAULT) </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits) </span><br><span class="line">RetryInstruction()</span><br></pre></td></tr></table></figure>

<p>访问流程:</p>
<ol>
<li>从虚拟地址中提取页号(VON)</li>
<li>检查TLB是否有该VVPN的转换映射。<ol>
<li>有TLB命中(TLB hit)，有该页的转换映射。</li>
<li>没有，检查失败<ol>
<li>硬件访问页表来寻找转换映射，并用该转换映射更新TLB</li>
<li>TLB更新后，系统重新尝试指令</li>
</ol>
</li>
</ol>
</li>
<li>从相关TLB项中取出页帧好(PFN),与原来虚拟地址中的偏移量组合形成期望的物理地址(PA),并访问内存行</li>
</ol>
<h3 id="示例-访问数组"><a href="#示例-访问数组" class="headerlink" title="示例:访问数组"></a>示例:访问数组</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">10</span>;++i)&#123;</span><br><span class="line">    sum+=a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://s2.loli.net/2023/07/27/6UMGy2Zu4nWcOvB.png" alt="TLB.png"></p>
<p>当访问第一个数组元素(a[0])是，CPU会看到载入虚拟地址100.硬件从中提取VPN（VPN&#x3D;06),然后检查TLB，寻找有效的转换映射。第一次访问，TLB未命中。</p>
<p>访问a[1],命中，TLB命中。往下的流程相似。</p>
<p>TLB的行为表现:未命中，命中，命中，未命中，命中，命中，命中，未命中，命中，命中。得到命中率未70%</p>
<p>由于时间局部性(temporal locality),即在短时间内对内存项再次引用，所以TLB命中率会很高。</p>
<blockquote>
<p><strong>尽可能利用缓存</strong></p>
<p>缓存是计算机系统中最基本的性能改进技术之一，一次又一次地用于让“常见的情况更快”。硬件缓存背后的思想是利用指令和数据引用的局部性（locality）。通常有两种局部性：时间局部性（temporal locality）和空间局部性（spatial locality）。</p>
<p>时间局部性是指，最近访问过的指令或数据项可能很快会再次访问。想想循环中的循环变量或指令，它们被多次反复访问。空间局部性是指，当程序访问内存地址 x 时，可能很快会访问邻近 x 的内存。想想遍历某种数组，访问一个接一个的元素。当然，这些性质取决于程序的特点，并不是绝对的定律，而更像是一种经验法则。</p>
<p>硬件缓存，无论是指令、数据还是地址转换（如 TLB），都利用了局部性，在小而快的芯片内存储器中保存一份内存副本。处理器可以先检查缓存中是否存在就近的副本，而不是必须访问（缓慢的）内存来满足请求。如果存在，处理器就可以很快地访问它（例如在几个 CPU 时钟内），避免花很多时间来访问内存（好多纳秒）。</p>
</blockquote>
<h3 id="谁来处理TLB未命中"><a href="#谁来处理TLB未命中" class="headerlink" title="谁来处理TLB未命中"></a>谁来处理TLB未命中</h3><p>TLB如果未命中，如何处理:硬件或软件。</p>
<p>硬件通过页表基址寄存器访问页表在内存中的确切位置以及格式。</p>
<p>发生 TLB 未命中时，硬件系统会抛出一个异常，这会暂停当前的指令流，将特权级提升至内核模式，跳转至陷阱处理程序（trap handler）。这个陷阱处理程序是操作系统的一段代码，用于处理 TLB 未命中。这段代码在运行时，会查找页表中的转换映射，然后用特别的“特权”指令更新 TLB，并从陷阱返回。此时，硬件会重试该指令（导致 TLB 命中）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT</span><br><span class="line">(Success,TlbEntry) = TLB_Lookup(VPN)</span><br><span class="line"><span class="keyword">if</span>(Success == True)</span><br><span class="line">    <span class="keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True) </span><br><span class="line">		Offset = VirtualAddress &amp; OFFSET_MASK </span><br><span class="line">		PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset </span><br><span class="line">		Register = AccessMemory(PhysAddr) </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    RaiseException(TLB_MISS)</span><br></pre></td></tr></table></figure>

<p>细节:</p>
<ol>
<li>此处陷入陷阱，从TLB未命中的陷阱返回后，硬件必须从导致陷阱的指令继续执行(而不是下一条指令。这次重试导致该执行再次执行，命中TLB。因此，根据陷阱或异常的原因，系统在陷入内核时必须保存不同的程序计数器，以便将来能够正确地继续执行</li>
<li>在运行TLB未命中处理代码时，操作系统需要小心避免引起TLB未命中的无限递归。解决方法:将TLB未命中陷阱处理程序直接放到物理内存中，就不会经过地址转换。或在 TLB 中保留一些项，记录永久有效的地址转换，并将其中一些永久地址转换槽块留给处理代码本身，这些被监听的（wired）地址转换总是会命中 TLB。</li>
</ol>
<p><strong>软件管理灵活且简单。</strong></p>
<h3 id="TLB的内容"><a href="#TLB的内容" class="headerlink" title="TLB的内容"></a>TLB的内容</h3><p>一条TLB项内容可能的格式:</p>
<p><code>VPN|PFN|其他位</code></p>
<blockquote>
<p><strong>TLB的有效位!&#x3D;页表的有效位</strong></p>
<p>TLB的有效位表示是否有有效的地址映射。</p>
<p>页表有效位表示进程是否有申请使用</p>
</blockquote>
<h3 id="上下文切换时对TLB的处理"><a href="#上下文切换时对TLB的处理" class="headerlink" title="上下文切换时对TLB的处理"></a>上下文切换时对TLB的处理</h3><p>TLB中包含的虚拟到物理的地址映射只对当前进程有效，对其他进程没有意义。</p>
<p>一个进程P1的10号虚拟页映射到100号物理帧，切换到进程P2，P2的10号虚拟页映射到170号物理帧。如下所示</p>
<p><img src="https://s2.loli.net/2023/07/27/uxXpDIqh2kYSbiv.png" alt="process-change-tlb.png"></p>
<p><strong>多进程的虚拟化</strong></p>
<blockquote>
<p><strong>进程切换时如何管理TLB的内容</strong></p>
<p>如果发生进程间上下文切换，上一个进程在TLB中的地址映射对于即将运行的进程是无意义的。硬件或操作系统应该如何解决这个问题？</p>
</blockquote>
<p><strong>解决方法:</strong></p>
<ol>
<li>上下文切换时，清空(flush)TLB。进程不会再读到错误的地址映射，但有一定的开销:每次都会触发TLB未命中</li>
<li>在TLB中添加地址空间标识符(Address Space Identifier,ASID)。可看作进程标识符PID。</li>
</ol>
<p><img src="https://s2.loli.net/2023/07/27/zsTBxi1kjh6oCH9.png" alt="ASID-TLB.png"></p>
<p><strong>TLB中不同的VPN指向了相同的PFN：</strong>共享代码页能减少对物理页的使用，从而减少了内存开销</p>
<h3 id="TLB替换策略"><a href="#TLB替换策略" class="headerlink" title="TLB替换策略"></a>TLB替换策略</h3><p>缓存替换(cache replacement)：向TLB插入新项时，会替换(replace)一个旧项。替换哪一个?</p>
<blockquote>
<p><strong>如何设计TLB替换</strong></p>
<p>在向TLB添加新项时，应该替换哪个旧项？提高命中率，从而改进性能</p>
</blockquote>
<ol>
<li>最近最少使用(least-recently-used,LRU)</li>
<li>随机策略(random)</li>
</ol>
<h3 id="实际系统的TLB表项"><a href="#实际系统的TLB表项" class="headerlink" title="实际系统的TLB表项"></a>实际系统的TLB表项</h3><p><img src="https://s2.loli.net/2023/07/27/biawIt1KTyXUpxh.png" alt="MIPS-TLB.png"></p>
<p>MIPS R40000支持32位的地址空间，页大小为4KB。所以在典型的虚拟地址中，预期会看到20位的VPN和12位的偏移量。但是，你可以在 TLB 中看到，只有 19 位的 VPN。事实上，用户地址只占地址空间的一半（剩下的留给内核），所以只需要 19 位的 VPN。VPN转换成最大 24 位的物理帧号（PFN），因此可以支持最多有 64GB 物理内存（224个 4KB 内存页）的系统。</p>
<blockquote>
<p><strong>RAM不总是RAM</strong></p>
<p>随机存取存储器(Random-Access Memory,RAM)暗示你访问RAM的任意部分都一样快。虽然一般这样想 RAM 没错，但因为 TLB 这样的硬件&#x2F;操作系统功能，访问某些内存页的开销较大，尤其是没有被 TLB 缓存的页。因此，最好记住这个实现的窍门：RAM 不总是 RAM。有时候随机访问地址空间，尤其是 TLB 没有缓存的页，可能导致严重的性能损失。</p>
</blockquote>
<p>TLB也不能满足所有程序的需求:</p>
<ol>
<li>超过TLB覆盖访问(TLB coverage):如果 一个程序短时间内访问的页数超过了TLB的页数，就会有大量的TLB未命中，运行速度变慢。解决方法:支持更大的页，把关键数据结构放在程序地址空间的某些区域，增加了有效覆盖率。</li>
<li>访问TLB很容易成为CPU流水线的瓶颈，尤其是有所谓的物理地址索引缓存(physically-indexed cache)。有了这种缓存，地址转换必须发生在访问该缓存之前，会让操作变慢。</li>
</ol>
<h2 id="分页-较小的表"><a href="#分页-较小的表" class="headerlink" title="分页:较小的表"></a>分页:较小的表</h2><p>如果页表太大，消耗的内存会太多。</p>
<blockquote>
<p><strong>如何让页表更小</strong></p>
<p>简单的基于数组的页表(线性页表)太大，在典型系统上占用太多内存。如何让页表更小?关键的思路？新的数据结构，会出现什么效率影响。</p>
</blockquote>
<h3 id="简单的解决方案-更大的页"><a href="#简单的解决方案-更大的页" class="headerlink" title="简单的解决方案:更大的页"></a>简单的解决方案:更大的页</h3><p>可以使用一种简单的方法减小页表大小:使用更大的页。</p>
<p>再以 32 位地址空间为例，但这次假设用 16KB 的页。因此，会有 18 位的 VPN 加上 14 位的偏移量。假设每个页表项（4字节）的大小相同，现在线性页表中有 218 个项，因此每个页表的总大小为 1MB，页表缩到四分之一。</p>
<p>**主要问题:**大内存会导致每页的浪费，产生内部碎片(internal fragmentation)。应用程序会分配页，但只用每页的一小部分，而内存很快旧会充满过大的页。</p>
<h3 id="混合方法-分页和分段"><a href="#混合方法-分页和分段" class="headerlink" title="混合方法:分页和分段"></a>混合方法:分页和分段</h3><p>将分页和分段结合，以减少页表的内存开销。</p>
<p>使用16KB的小地址空间和1KB的页。</p>
<p><img src="https://s2.loli.net/2023/07/30/qXM63eUoDjNEwld.png" alt="hybird.png"></p>
<p>大部分的页表都没有使用，造成了空间浪费。</p>
<p>混合方法不是为进程的整个地址空间提高单个页表，而是为每个逻辑分段提高一个。例如代码、堆和栈部分各有一个。</p>
<p>混合方法依然有MMU结构，基址不指向段本身。而是保存该段的页表的物理地址，界限寄存器用于只是页表的结尾(有多少页)</p>
<p><img src="https://s2.loli.net/2023/07/30/KcyAuTZadQfJF6B.png" alt="virtual-address-Seg.png"></p>
<p>每个段的基址寄存器都包含该段的线性页表的物理地址。因此，系统中的每个进程现在都有3各与其关联的页表。在上下文切换时，必须更改这些寄存器。在TLB未命中时时，<strong>硬件使用分段位（SN）来确定要使用的基址和界限对。</strong>然后将其中的物理地址与VON结合，形成页表项(PTE)的地址。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SN = (VirtualAddress &amp; SEG_MASK) &gt;&gt; SN_SHIFT</span><br><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; VPN_SHIFT</span><br><span class="line">AddressOfPTR = Base[SN] + (VPN * <span class="keyword">sizeof</span>(PTE))</span><br></pre></td></tr></table></figure>

<p>代码中只使用3个段基址寄存器中的一个，而不是单个页表基址寄存器。每个分段都有界限寄存器，每个界限寄存器保存了段中最大有效页的值。内存访问超出段的末尾将产生一个异常，并可能导致进程终止。</p>
<p><strong>主要问题:</strong></p>
<p>使用分段，单分段不是那么灵活，因为它假定地址空间有一定的使用模式。</p>
<p>尽管内存是以页面大小单位管理，单页表可以是任意大小。导致外部碎片，空间复杂</p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>如何去掉页表中的所有无效区域，而不是将透明全部保留在内存中。</p>
<p><strong>多级页表(multi-level page table)：</strong>将线性页表变成了类似树的东西。</p>
<p><strong>思想:</strong></p>
<ol>
<li>将页表分成页大小的单元。</li>
<li>如果整页的页表项(PTE)无效，就完全不分配该页的页表。</li>
</ol>
<p>为了追踪页表的页是否有效(以及有效是，在内存中的位置)，使用了页目录(page directory)的新结构。&#x3D;&#x3D;页目录可以告诉页表的页在哪，或者整个页不包含有效页。&#x3D;&#x3D;</p>
<p><img src="https://s2.loli.net/2023/07/30/Bs6jcwG1gFQeqDJ.png" alt="multi-level-page.png"></p>
<p><strong>线性页表:</strong></p>
<p>即使地址空间的大部分中间区域无效，我们仍然需要为这些区域分配页表空间。</p>
<p>**多级页表:**页目录仅将页表的两页标记为有效(第一个和最后一个),因此页表这两项驻留在内存中。只是让线性页表中的一部分消失,并用页目录来记录页表的哪些页被分配。</p>
<p>在一个简单的两级页表中，页目录为每页页表包含了一项。由多个页目录项(Page Directory Entries,PDE)组成。PDE至少拥有有效位(valid bit)和页帧号(page frame number,PFN)。**此处的有效位:**如果有效，该项指向的页表中至少由一页是有效的（在该PDE所指向的页中，至少一个PTE的有效位被设置为1）</p>
<p><strong>优点:</strong></p>
<ol>
<li>多级页表分配的页表空间，与正在使用的地址空间内存成比例。</li>
<li>页表的每个部分都可以整齐地放入一页中，从而更容易管理内存。</li>
<li>增加了一个间接层(level of indirection)，使用页目录，指向页表的各个部分。</li>
</ol>
<blockquote>
<p><strong>理解时空折中</strong></p>
<p>在构造数据结构时，应时钟考虑时间和空间的折中(time-space trade-off)。如果你希望更快地访问特定的数据结构，就必须为该结构付出空间代价。</p>
</blockquote>
<p><strong>缺点:</strong></p>
<ol>
<li>TLB未命中时，需要从内存中加载两次，才能从页表中获取正确的地址转换信息(一次用于页目录，一次用于PTE本身)</li>
<li>复杂性:无论是硬件还是操作系统来处理页表查找(在TLB未命中是)，使得查找更复杂。</li>
</ol>
<p><strong>详细的多级示例:</strong></p>
<p>一个大小为16KB的小地址空间，其中包含64字节的页(一个页的大小,偏移量)，因此有14位的虚拟地址空间，VPN有8位，偏移量有6位。即使只有一小部分地址空间正在使用，线性页表也会有2^8^个项。</p>
<p><img src="https://s2.loli.net/2023/07/31/e9ydMfVW8aoACLx.png" alt="multi-level-example.png"></p>
<p>虚拟页0和1用于代码，虚拟页4和5用于堆，虚拟页254和255用于栈。其他地址空间未被使用。</p>
<p>完整页表有256个项，假设每个PTE的大小是4个字节，因此，页大小为1KB（256*4），我们有64字节的页，1KB页表可以分为16个64字节的页，每个页可以容纳16个PTE。</p>
<p><strong>获取VPN，如何为每个VPN构建索引:</strong></p>
<ol>
<li>256个项，分布在16个页上。页目录需要为页表的每页提供一个项。因此有16个页目录项。我们使用前4位VPN来索引目录</li>
</ol>
<p><img src="https://s2.loli.net/2023/07/31/5MOA1LzJpmGqTdX.png" alt="VPN-dir-num.png"></p>
<ol start="2">
<li><p>一旦从VPN中提取了页目录索引(PDIndex),我们就可以通过计算找到页目录项(PDE)的位置PDEAddr &#x3D; PageDirBase + (PDIndex *sizeof(PDE))。得到页目录</p>
</li>
<li><p>如果无效，从而引发异常。有效，从页目录项指向的页表的页中获取页表项(PTE)，要找到这个PTE，使用VPN的剩余位索引到页表的部分</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2023/07/31/xu6rAXMb93IYfej.png" alt="VPN-PTE-num.png"></p>
<ol start="4">
<li><strong>页表索引</strong>(Page-Table Index,PTIndex)用来索引页表本身，给出PTE的地址:PTEAddr &#x3D; (PDE.PFN &lt;&lt; SHITT)+(PTIndex * sizeof(PTE))</li>
</ol>
<h3 id="反向页表"><a href="#反向页表" class="headerlink" title="反向页表"></a>反向页表</h3><p>**反向页表(inverted page table):**操作系统中保留了一个页表，其中的项代表系统的每个物理页，而不是许多页表(系统的每个进程一个)。页表项告诉我们哪个进程正在使用此页，以及该进程的哪个虚拟页映射到此物理页。</p>
<h3 id="将页表交换到磁盘"><a href="#将页表交换到磁盘" class="headerlink" title="将页表交换到磁盘"></a>将页表交换到磁盘</h3><p>目前为止，一直假设页表位于内核拥有的物理内存中。即使我们有很多技巧来减小页表的大小，但是它仍然有可能是太大而无法一次装入内存。异常，一些系统将这样的页表放入内核虚拟内存(kernel virtual memory)，从而允许系统在内存压力较大时，将页表中的一部分交换到磁盘。</p>
<h2 id="超越物理内存-机制"><a href="#超越物理内存-机制" class="headerlink" title="超越物理内存:机制"></a>超越物理内存:机制</h2><p>当地址空间较大时，物理内存放不下，需要在内存层级(memory hierarchy)上再加一层。操作系统需要把当前没有用的部分存储起来，放再硬盘(hard disk drive)。</p>
<blockquote>
<p><strong>如何超越物理内存</strong></p>
<p>操作系统如何利用大而慢的设备，透明地提供巨大虚拟地址空间的假象?</p>
</blockquote>
<p>为什么要为进程支持巨大的地址空间:方便和易用性</p>
<p>有了巨大的地址空间，就不必担心程序的数据结构是否有足够的空间存储。早期系统使用”内存覆盖”,需要程序原手动移入或移出内存中的代码和数据。</p>
<h3 id="交换空间"><a href="#交换空间" class="headerlink" title="交换空间"></a>交换空间</h3><p>在硬盘上开辟一部分空间用于物理页的移入和移出。在操作系统中，称这样的空间为交换空间(swap space),将内存中的页交换到其中,并在需要的时候又交换回去。我们假设操作系统能够以页大小为单元读取或写入交换空间。操作系统需要记住给定页的硬盘地址(disk address)</p>
<p><img src="https://s2.loli.net/2023/07/31/N4ejvhC2zLDnVBO.png" alt="swap space.png"></p>
<h3 id="存在位"><a href="#存在位" class="headerlink" title="存在位"></a>存在位</h3><p>当硬件在PTE中查找时，可能发现页不在物理内存中。硬件(或操作系统)判断是否在内存中的方法，是通过页表项中的一条新信息，即存在位(present bit)。如果存在位设置为 1，则表示该页存在于物理内存中。如果为0，则在硬盘上。</p>
<p>访问不在物理内存中的页，这种行为通常被称为<strong>页错误</strong>（page fault）。在页错误时，操作系统被唤起来处理页错误。一段称为“页错误处理程序（page-fault handler）”的代码会执行，来处理页错误。</p>
<h3 id="页错误"><a href="#页错误" class="headerlink" title="页错误"></a>页错误</h3><p><strong>操作系统</strong>处理页错误。操作系统用PTE的某些位来存储硬盘地址，这些位通常用来存储页的PFN，在PTE中查找地址，并将请求发送到硬盘，将页读取到内存中。</p>
<blockquote>
<p><strong>为什么硬件不能处理页错误</strong></p>
<ol>
<li>页错误导致的硬盘操作很慢。(即使操作系统执行相比硬盘操作，开销很小)</li>
<li>硬件必须了解交换空间，如何向硬盘发送I&#x2F;O操作等细节</li>
</ol>
</blockquote>
<p>当硬盘 I&#x2F;O 完成时，操作系统会更新页表，将此页标记为存在，更新页表项（PTE）的PFN 字段以记录新获取页的内存位置，并重试指令。</p>
<p>请注意，当 I&#x2F;O 在运行时，进程将处于阻塞（blocked）状态。因此，当页错误正常处理时，操作系统可以自由地运行其他可执行的进程。因为 I&#x2F;O 操作是昂贵的，一个进程进行I&#x2F;O（页错误）时会执行另一个进程，这种交叠（overlap）是多道程序系统充分利用硬件的一种方式。</p>
<h3 id="内存满了怎么办"><a href="#内存满了怎么办" class="headerlink" title="内存满了怎么办"></a>内存满了怎么办</h3><p>在上面描述的过程中，你可能会注意到，我们假设有足够的空闲内存来从存储交换空间换入（page in）的页。当然，情况可能并非如此。内存可能已满（或接近满了）。因此，操作系统可能希望先交换出（page out）一个或多个页，以便为操作系统即将交换入的新页留出空间。选择哪些页被交换出或被替换（replace）的过程，被称为<strong>页交换策略</strong>（page-replacement policy）。</p>
<h3 id="页错误处理流程"><a href="#页错误处理流程" class="headerlink" title="页错误处理流程"></a>页错误处理流程</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">VPN = (VirtualAddress &amp; VPN_MASK) &gt;&gt; SHIFT </span><br><span class="line">(Success, TlbEntry) = TLB_Lookup(VPN) </span><br><span class="line"><span class="keyword">if</span> (Success == True) <span class="comment">// TLB Hit </span></span><br><span class="line">	<span class="keyword">if</span> (CanAccess(TlbEntry.ProtectBits) == True) </span><br><span class="line">		Offset = VirtualAddress &amp; OFFSET_MASK </span><br><span class="line">		PhysAddr = (TlbEntry.PFN &lt;&lt; SHIFT) | Offset </span><br><span class="line">		Register = AccessMemory(PhysAddr) </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">	RaiseException(PROTECTION_FAULT)</span><br><span class="line"><span class="keyword">else</span> <span class="comment">// TLB Miss </span></span><br><span class="line">	PTEAddr = PTBR + (VPN * <span class="keyword">sizeof</span>(PTE)) </span><br><span class="line">	PTE = AccessMemory(PTEAddr) </span><br><span class="line">	<span class="keyword">if</span> (PTE.Valid == False) </span><br><span class="line">		RaiseException(SEGMENTATION_FAULT) </span><br><span class="line">	<span class="keyword">else</span> </span><br><span class="line">		<span class="keyword">if</span> (CanAccess(PTE.ProtectBits) == False) </span><br><span class="line">			RaiseException(PROTECTION_FAULT) </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (PTE.Present == True) </span><br><span class="line">			<span class="comment">// assuming hardware-managed TLB </span></span><br><span class="line">			TLB_Insert(VPN, PTE.PFN, PTE.ProtectBits) </span><br><span class="line">			RetryInstruction() </span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (PTE.Present == False) </span><br><span class="line">			RaiseException(PAGE_FAULT)</span><br></pre></td></tr></table></figure>

<p>第一种情况，该页存在（present）且有效（valid）（第 18～21 行）。在这种情况下，TLB 未命中处理程序可以简单地从 PTE 中获取 PFN，然后重试指令（这次 TLB 会命中），并因此继续前面描述的流程。第二种情况（第 22～23 行），页错误处理程序需要运行。虽然这是进程可以访问的合法页（毕竟是有效的），但它并不在物理内存中。第三种情况，访问的是一个无效页，可能由于程序中的错误（第 13～14 行）。在这种情况下，PTE 中的其他位都不重要了。硬件捕获这个非法访问，操作系统陷阱处理程序运行，可能会杀死非法进程。</p>
<h3 id="交换何时发生"><a href="#交换何时发生" class="headerlink" title="交换何时发生"></a>交换何时发生</h3><p>操作系统只会在内存满了的时候进行交换吗？</p>
<p>为了保证又少量的空闲内存，大多数操作系统会设置高水位线(High Watermark,HW)和低水位线(Low Watermark,LW)，来决定何时从内存中清除页。</p>
<p>&#x3D;&#x3D;原理:&#x3D;&#x3D;当操作系统发现有少于 LW 个页可用时，后台负责释放内存的线程会开始运行，直到有 HW 个可用的物理页。这个后台线程有时称为<strong>交换守护进程</strong>（swap daemon）或<strong>页守护进程</strong>（page daemon），它然后会很开心地进入休眠状态，因为它毕竟为操作系统释放了一些内存。</p>
<p><strong>通过同时执行多个交换过程，我们可以进行一些性能优化</strong>。例如，许多系统会把多个要写入的页聚集(cluster)或分组(group)，同时写入到交换区间，从而提高硬盘的效率。</p>
<p>为了配合后台的分页线程。交换算法会简单检查是否又空闲页，而不是直接执行替换。如果没有,通知后台分页线程按需要释放页，当线程释放一定数目的页是，会唤醒原来的线程，就可以把需要的页换进内存。</p>
<blockquote>
<p><strong>把一些工作放在后台</strong></p>
<p>当你有一些工作要做的时候，把这些工作放在后台（background）运行是一个好注意，可以提高效率，并允许将这些操作合并执行。</p>
<p>操作系统通常在后台执行很多工作，如在将数据写入硬盘之前，许多系统在内存中缓冲要写入的数据。</p>
</blockquote>
<h2 id="超越物理内存-策略"><a href="#超越物理内存-策略" class="headerlink" title="超越物理内存:策略"></a>超越物理内存:策略</h2><p>在这种情况下，由于内存压力（memory pressure）迫使操作系统换出（paging out）一些页，为常用的页腾出空间。确定要踢出（evict）哪个页（或哪些页）封装在操作系统的替换策略（replacement policy）中。</p>
<blockquote>
<p><strong>如何决定提出哪个页</strong></p>
<p>操作系统如何决定从内存中踢出哪一页(或哪几页)?这个决定由系统的替换策略做出，替换策略通常会遵循一些通用的原则（下面将会讨论），但也会包括一些调整，以避免特殊情况下的行为。</p>
</blockquote>
<h3 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h3><p>由于内存只包含系统中所有页的子集，因此可以将其视为系统中虚拟内存页的缓存（cache）。因此，在为这个缓存选择替换策略时，我们的目标是让<strong>缓存未命中（cache miss）最少</strong>，即使得&#x3D;&#x3D;从磁盘获取页的次数最少&#x3D;&#x3D;。或者，可以将目标看成让<strong>缓存命中（cache hit）最多</strong>，即在&#x3D;&#x3D;内存中找到待访问页的次数最多&#x3D;&#x3D;。</p>
<p>可通过缓存命中和未命中次数，计算程序的平均内存访问时间(Average Memory Access Time,AMAT):</p>
<p>AMAT &#x3D; (P<del>Hit</del>* T<del>M</del>)+(P<del>Miss</del>* T<del>D</del>)</p>
<p>T<del>M</del>:内存访问的成本，T<del>D</del>:磁盘访问的成本</p>
<p>现代系统中，磁盘访问的成本非常高，计算很小概率的未命中也会拉低正在运行的程序的总体AMAT。</p>
<h3 id="最优替换策略"><a href="#最优替换策略" class="headerlink" title="最优替换策略"></a>最优替换策略</h3><p>最优替换策略能达到总体未命中数量最少。替换内存中在最远将来才会被访问到的页。</p>
<blockquote>
<p>虽然最优策略非常不切实际，但作为仿真或其他研究的比较者还是非常有用的。比如，单说你喜欢的新算法有 80%的命中率是没有意义的，但加上最优算法只有 82%的命中率（因此你的新方法非常接近最优），就会使得结果很有意义，并给出了它的上下文。因此，在你进行的任何研究中，知道最优策略可以方便进行对比，知道你的策略有多大的改进空间，也用于决定当策略已经非常接近最优策略时，停止做无谓的优化[</p>
</blockquote>
<p><img src="https://s2.loli.net/2023/07/31/o6VEMC2BziD5LuQ.png" alt="optimal.png"></p>
<p>一开始缓存是空的，这种未命中称未冷启动未命中(cold-start miss，或强制未命中,compulsory miss)。</p>
<p>命中率很高，但未来的访问，无法知道，所有，其他策略可与这种策略进行比较，估计策略的适合度。</p>
<h3 id="简单策略-FIFO"><a href="#简单策略-FIFO" class="headerlink" title="简单策略:FIFO"></a>简单策略:FIFO</h3><p>如图:</p>
<p><img src="https://s2.loli.net/2023/07/31/1mB6LMUTthRDagS.png" alt="memory-policy-FIFO.png"></p>
<h3 id="另一简单策略-随机"><a href="#另一简单策略-随机" class="headerlink" title="另一简单策略:随机"></a>另一简单策略:随机</h3><p>如图:</p>
<p><img src="https://s2.loli.net/2023/07/31/i61MxSUjt9Rd48Q.png" alt="memory-policy-random.png"></p>
<h3 id="利用历史数据-LRU"><a href="#利用历史数据-LRU" class="headerlink" title="利用历史数据:LRU"></a>利用历史数据:LRU</h3><p>页替换策略使用频率(frequency)。如果一个页被访问了多此，就不应该被替换，因为它跟具有价值。页更常用的属性是访问的近期性(recency)。</p>
<p>这类策略就是<strong>局部性原则(principle of locality)</strong></p>
<blockquote>
<p><strong>局部性类型</strong></p>
<ol>
<li>空间局部性(spatial locality):如果页 P 被访问，可能围绕它的页（比如 P−1 或 P + 1）也会被访问。</li>
<li>时间局部性(temporal locality):近期访问过的页面很可能在不久的将来再次访问</li>
</ol>
</blockquote>
<p>如同:</p>
<p>&#x2F;&#x2F;LRU</p>
<p>已经快赶上最优策略了</p>
<h3 id="时钟算法"><a href="#时钟算法" class="headerlink" title="时钟算法"></a>时钟算法</h3><p>时钟算法(clock algorithm)。</p>
<p>假设所有页都放在一个循环列表中。</p>
<ol>
<li>时钟指针(clock hand)开始时，执行某个页。</li>
<li>进行页替换时，操作系统检查当前执行的页p的使用位是1还是0<ol>
<li>1表示最近使用，不适合替换，设置为0</li>
<li>找下一个，如果为0表示最近每使用，替换出去</li>
</ol>
</li>
</ol>
<h3 id="脏页"><a href="#脏页" class="headerlink" title="脏页"></a>脏页</h3><p>时钟算法的一个小修改，是对内存中的页是否被修改的额外考虑。</p>
<p>**原因:**如果页已被修改（modified）并因此变脏（dirty），则踢出它就必须将它写回磁盘，这很昂贵。如果它没有被修改（因此是干净的，clean），踢出就没成本。物理帧可以简单地重用于其他目的而无须额外的I&#x2F;O。</p>
<p>所以，硬件应该包含一个修改位(modified bit,也就是脏位,dirty bit)</p>
<h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p><strong>当内存被超额请求时，操作系统该做什么，这组正在运行的进程的内存需求是否超出了可用物理内存?</strong></p>
<p>这种情况下，系统将不断换页，这种情况称为抖动(thrashing)</p>
<p>一些早期的操作系统有一组相当复杂的机制，以便在抖动发生时检测并应对。例如，给定一组进程，系统可以决定不运行部分进程，希望减少的进程工作集（它们活跃使用的页面）能放入内存，从而能够取得进展。</p>
<h3 id="小结-4"><a href="#小结-4" class="headerlink" title="小结"></a>小结</h3><p>在许多情况下，由于内存访问和磁盘访问时间之间的差异增加，这些算法的重要性降低了。由于分页到硬盘非常昂贵，因此频繁分页的成本太高。所以，过度分页的最佳解决方案往往很简单：购买更多的内存</p>
<h2 id="VAX-x2F-VMS虚拟内存系统"><a href="#VAX-x2F-VMS虚拟内存系统" class="headerlink" title="VAX&#x2F;VMS虚拟内存系统"></a>VAX&#x2F;VMS虚拟内存系统</h2><p>VAX&#x2F;VMS操作系统面临着通用性的问题，即需要在各种机器上运行。</p>
<blockquote>
<p><strong>如何避免通用性”魔咒”</strong></p>
<p>为广泛的应用程序和系统提供一般支持。其根本结果是操作系统不太可能很好地支持任何一个安装。</p>
</blockquote>
<h3 id="内存管理硬件"><a href="#内存管理硬件" class="headerlink" title="内存管理硬件"></a>内存管理硬件</h3><p>VAX-11为每个进程提供了一个32位虚拟地址空间，分为512字节的页。因此，虚拟地址空间由23位VPN和9位偏移组成。VPN的高两位用于区分页所在的段。</p>
<p>(<strong>该系统是分段和分页的混合</strong>)</p>
<p>地址空间的下半部分被称为”进程空间”。对于每个进程都是唯一的。</p>
<p>vax硬件中的页大小非常小(512字节)。所以设计人员的首要目标之一是确保VMS不会用页表占满内存。</p>
<p><img src="https://s2.loli.net/2023/08/02/k27ytJUGLlM8I35.png" alt="VAX、VMS-address-space.png"></p>
<p>系统通过两种方式，减少页表对内存的压力:</p>
<ol>
<li>通过将用户地址空间分位两部分，VAX-11文明每个进程的每个区域(P0和P1)提供了一个页表。因此，栈和堆之间未使用的地址空间部分不需要页表空间。基址和界限寄存器的使用与你期望的一样。一个基址寄存器保存该段的页表的地址，界限寄存器保存其大小（即页表项的数量）。</li>
<li>在内核虚拟内存中放置用户页表(对于P0和P1，因此每个进程两个)，操作系统进一步降低了内存压力。</li>
</ol>
<p>因此，在分配或增长页表时，内核在段 S 中分配自己的虚拟内存空间。如果内存受到严重压力，内核可以将这些页表的页面交换到磁盘，从而使物理内存可以用于其他用途。</p>
<h3 id="一个真实的地址空间"><a href="#一个真实的地址空间" class="headerlink" title="一个真实的地址空间"></a>一个真实的地址空间</h3><blockquote>
<p><strong>为什么空指针访问会导致段错误</strong></p>
<p>int *p &#x3D; NULL;(p&#x3D;0)</p>
<p>*p &#x3D; 10;</p>
<p>硬件试图在 TLB 中查找 VPN（这里也是 0），遇到 TLB 未命中。查询页表，并且发现 VPN 0 的条目被标记为无效。因此，我们遇到无效的访问，将控制权交给操作系统，这可能会终止进程（在 UNIX 系统上，会向进程发出一个信号，让它们对这样的错误做出反应。但是如果信号未被捕获，则会终止进程）。</p>
</blockquote>
<p>代码段永远不会从第0页开始。相反，该页被标记位不可访问，以便为检测空指针(null-pointer)访问提供一些支持。因此，设计地址空间时需要考虑的一个问题是对调试的支持，这正是无法访问的零页所提供的。</p>
<p>操作系统不希望用户应用程序读取或写入操作系统数据或代码。因此，硬件必须支持页面的不同保护级别才能启用此功能。VAX通过在页表中的保护位中指定CPU 访问特定页面所需的特权级别来实现此目的。因此，系统数据和代码被设置为比用户数据和代码更高的保护级别。试图从用户代码访问这些信息，将会在操作系统中产生一个陷阱，并且（你猜对了）可能会终止违规进程。</p>
<h3 id="页替换"><a href="#页替换" class="headerlink" title="页替换"></a>页替换</h3><p>VAX中的页表项PTE包含以下位:一个有效位，一个保护字段（4位),一个修改位（脏位），为OS保留的字段5位，最后一个物理帧号码(PFN)将页面的位置存储在物理内存中。</p>
<h3 id="按需置零和写入时复制"><a href="#按需置零和写入时复制" class="headerlink" title="按需置零和写入时复制"></a>按需置零和写入时复制</h3><p>VMS由两个标准的技巧：按需置零和写入时复制.</p>
<p>**按需置零(demand zeroing):**在一个初级实现中，操作系统响应一个请求，在物理内存中找到页，将该页添加到堆中，并将其置零（安全起见，这是必需的。否则，你可以看到其他进程使用该页时的内容。），然后将其映射到你的地址空间（设置页表以根据需要引用该物理页）。但是初级实现可能是昂贵的，特别是如果页没有被进程使用。</p>
<p>利用按需置零，当页添加到你的地址空间时，操作系统的工作很少。它会在页表中放入一个标记页不可访问的条目。如果进程读取或写入页，则会向操作系统发送陷阱。在处理陷阱时，操作系统注意到（通常通过页表项中“保留的操作系统字段”部分标记的一些位），这实际上是一个按需置零页。<strong>此时，操作系统会完成寻找物理页的必要工作，将它置零，并映射到进程的地址空间。如果该进程从不访问该页，则所有这些工作都可以避免，从而体现按需置零的好处。</strong></p>
<blockquote>
<p><strong>惰性</strong></p>
<p>惰性可以使得工作推迟，但出于多种原因，这在操作系统中是有益的。首先，推迟工作可能会减少当前操作的延迟，从而提高响应能力。例如，操作系统通常会报告立即写入文件成功，只是稍后在后台将其写入硬盘。其次，更重要的是，惰性有时会完全避免完成这项工作。例如，延迟写入直到文件被删除，根本不需要写入。</p>
</blockquote>
<p>**写时复制(copy-on-write,COW):**如果操作系统需要将一个页面从一个地址空间复制到另一个地址空间，不是实际复制它，而是将其映射到目标地址空间，并在两个地址空间中将其标记为只读。如果两个地址空间都只读取页面，则不采取进一步的操作，因此操作系统已经实现了快速复制而不实际移动任何数据。</p>
<p>如果其中一个地址空间确实尝试写入页面，就会陷入操作系统。操作系统会注意到该页面是一个 COW 页面，因此（惰性地）分配一个新页，填充数据，并将这个新页映射到错误处理的地址空间。该进程然后继续，现在有了该页的私人副本。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">guesscyj</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/07/14/OS/">http://example.com/2023/07/14/OS/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">BLOG</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/18/OSBlog/" title="OSBlog"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">OSBlog</div></div></a></div><div class="next-post pull-right"><a href="/2023/07/13/STL/" title="STL"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">STL</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">guesscyj</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">2</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA%E3%80%8B%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">《操作系统导论》笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.1.</span> <span class="toc-text">操作系统介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96CPU"><span class="toc-number">1.1.1.</span> <span class="toc-text">虚拟化CPU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%8C%96%E5%86%85%E5%AD%98"><span class="toc-number">1.1.2.</span> <span class="toc-text">虚拟化内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91-concurrency"><span class="toc-number">1.1.3.</span> <span class="toc-text">并发(concurrency)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7"><span class="toc-number">1.1.4.</span> <span class="toc-text">持久性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">1.1.5.</span> <span class="toc-text">设计目标</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1-%E8%BF%9B%E7%A8%8B-process"><span class="toc-number">1.2.</span> <span class="toc-text">抽象:进程(process)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1-%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">抽象:进程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8BAPI"><span class="toc-number">1.2.2.</span> <span class="toc-text">进程API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%EF%BC%9A%E6%9B%B4%E5%A4%9A%E7%BB%86%E8%8A%82"><span class="toc-number">1.2.3.</span> <span class="toc-text">进程创建：更多细节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">进程状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.5.</span> <span class="toc-text">数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8BAPI-1"><span class="toc-number">1.3.</span> <span class="toc-text">进程API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fork-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.1.</span> <span class="toc-text">fork()系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">1.3.2.</span> <span class="toc-text">wait()系统调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec"><span class="toc-number">1.3.3.</span> <span class="toc-text">exec()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1API"><span class="toc-number">1.3.4.</span> <span class="toc-text">为什么这样设计API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6-%E5%8F%97%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.</span> <span class="toc-text">机制:受限直接执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E9%99%90%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.1.</span> <span class="toc-text">受限直接执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.2.</span> <span class="toc-text">受限制的操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E5%88%87%E6%8D%A2"><span class="toc-number">1.4.3.</span> <span class="toc-text">在进程之间切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%85%E5%BF%83%E5%B9%B6%E5%8F%91%E5%90%97"><span class="toc-number">1.4.4.</span> <span class="toc-text">担心并发吗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.5.</span> <span class="toc-text">进程调度:介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E5%81%87%E8%AE%BE"><span class="toc-number">1.5.1.</span> <span class="toc-text">工作负载假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E6%8C%87%E6%A0%87"><span class="toc-number">1.5.2.</span> <span class="toc-text">调度指标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA-FIFO"><span class="toc-number">1.5.3.</span> <span class="toc-text">先进先出(FIFO)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BB%BB%E5%8A%A1%E4%BC%98%E5%85%88-SJF"><span class="toc-number">1.5.4.</span> <span class="toc-text">最短任务优先(SJF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E5%AE%8C%E6%88%90%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88-STCF"><span class="toc-number">1.5.5.</span> <span class="toc-text">最短完成时间优先(STCF)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B0%E5%BA%A6%E9%87%8F%E6%8C%87%E6%A0%87-%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4"><span class="toc-number">1.5.6.</span> <span class="toc-text">新度量指标:响应时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC-RR"><span class="toc-number">1.5.7.</span> <span class="toc-text">轮转(RR)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E5%90%88I-x2F-O"><span class="toc-number">1.5.8.</span> <span class="toc-text">结合I&#x2F;O</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E6%B3%95%E9%A2%84%E7%9F%A5"><span class="toc-number">1.5.9.</span> <span class="toc-text">无法预知</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6-%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97-MLFQ"><span class="toc-number">1.6.</span> <span class="toc-text">调度:多级反馈队列(MLFQ)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MLFQ-%E5%9F%BA%E6%9C%AC%E8%A7%84%E5%88%99"><span class="toc-number">1.6.1.</span> <span class="toc-text">MLFQ:基本规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%951-%E5%A6%82%E4%BD%95%E6%94%B9%E5%8F%98%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.6.2.</span> <span class="toc-text">尝试1:如何改变优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B1-%E5%8D%95%E4%B8%AA%E9%95%BF%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">实例1:单个长工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B2-%E7%9F%AD%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">实例2:短工作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B3-%E6%9C%89I-x2F-O"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">实例3:有I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E5%89%8DMLFQ%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">当前MLFQ的一些问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%952-%E6%8F%90%E5%8D%87%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.6.3.</span> <span class="toc-text">尝试2:提升优先级</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%953-%E6%9B%B4%E5%A5%BD%E7%9A%84%E8%AE%A1%E6%97%B6%E6%96%B9%E5%BC%8F"><span class="toc-number">1.6.4.</span> <span class="toc-text">尝试3:更好的计时方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MLFQ%E8%B0%83%E5%BA%A6%E5%8F%8A%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.5.</span> <span class="toc-text">MLFQ调度及其他问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.6.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6-%E6%AF%94%E9%A2%9D%E4%BB%BD%E9%A2%9D"><span class="toc-number">1.7.</span> <span class="toc-text">调度:比额份额</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-%E5%BD%A9%E7%A5%A8%E8%A1%A8%E7%A4%BA%E4%BB%BD%E9%A2%9D"><span class="toc-number">1.7.1.</span> <span class="toc-text">基本概念:彩票表示份额</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A9%E7%A5%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.7.2.</span> <span class="toc-text">彩票机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.7.3.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">1.7.4.</span> <span class="toc-text">一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%86%E9%85%8D%E5%BD%A9%E7%A5%A8"><span class="toc-number">1.7.5.</span> <span class="toc-text">如何分配彩票</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E7%A1%AE%E5%AE%9A%E7%9A%84"><span class="toc-number">1.7.6.</span> <span class="toc-text">为什么不是确定的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-1"><span class="toc-number">1.7.7.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6-%E9%AB%98%E7%BA%A7"><span class="toc-number">1.8.</span> <span class="toc-text">多处理器调度(高级)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%8C%E6%99%AF-%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E6%9E%B6%E6%9E%84"><span class="toc-number">1.8.1.</span> <span class="toc-text">背景:多处理器架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%AB%E5%BF%98%E4%BA%86%E5%90%8C%E6%AD%A5"><span class="toc-number">1.8.2.</span> <span class="toc-text">别忘了同步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98-%E7%BC%93%E5%AD%98%E4%BA%B2%E5%92%8C%E5%BA%A6"><span class="toc-number">1.8.3.</span> <span class="toc-text">最后一个问题:缓存亲和度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="toc-number">1.8.4.</span> <span class="toc-text">单队列调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%98%9F%E5%88%97%E8%B0%83%E5%BA%A6"><span class="toc-number">1.8.5.</span> <span class="toc-text">多队列调度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E8%B0%83%E5%BA%A6"><span class="toc-number">1.8.6.</span> <span class="toc-text">Linux多处理器调度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECPU%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">关于CPU虚拟化的总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%86%85%E5%AD%98%E8%99%9A%E6%8B%9F%E5%8C%96%E7%9A%84%E5%AF%B9%E8%AF%9D"><span class="toc-number">1.10.</span> <span class="toc-text">关于内存虚拟化的对话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1-%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.11.</span> <span class="toc-text">抽象:地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A9%E6%9C%9F%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.11.1.</span> <span class="toc-text">早期系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E5%92%8C%E6%97%B6%E5%88%86%E5%85%B1%E4%BA%AB"><span class="toc-number">1.11.2.</span> <span class="toc-text">多道程序和时分共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.11.3.</span> <span class="toc-text">地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E6%A0%87"><span class="toc-number">1.11.4.</span> <span class="toc-text">目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-2"><span class="toc-number">1.11.5.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%8F%99-%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9CAPI"><span class="toc-number">1.12.</span> <span class="toc-text">插叙:内存操作API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.12.1.</span> <span class="toc-text">内存类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#malloc-%E8%B0%83%E7%94%A8"><span class="toc-number">1.12.2.</span> <span class="toc-text">malloc()调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-%E8%B0%83%E7%94%A8"><span class="toc-number">1.12.3.</span> <span class="toc-text">free()调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF"><span class="toc-number">1.12.4.</span> <span class="toc-text">常见错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81"><span class="toc-number">1.12.5.</span> <span class="toc-text">底层操作系统支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E8%B0%83%E7%94%A8"><span class="toc-number">1.12.6.</span> <span class="toc-text">其他调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6-%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.13.</span> <span class="toc-text">机制:地址转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%AE%BE"><span class="toc-number">1.13.1.</span> <span class="toc-text">假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90-1"><span class="toc-number">1.13.2.</span> <span class="toc-text">一个例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81-%E5%9F%BA%E4%BA%8E%E7%A1%AC%E4%BB%B6-%E9%87%8D%E5%AE%9A%E4%BD%8D"><span class="toc-number">1.13.3.</span> <span class="toc-text">动态(基于硬件)重定位</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.13.3.1.</span> <span class="toc-text">转换示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E6%94%AF%E6%8C%81-%E6%80%BB%E7%BB%93"><span class="toc-number">1.13.4.</span> <span class="toc-text">硬件支持:总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.13.5.</span> <span class="toc-text">操作系统的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-3"><span class="toc-number">1.13.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5"><span class="toc-number">1.14.</span> <span class="toc-text">分段</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5-%E6%B3%9B%E5%8C%96%E7%9A%84%E5%9F%BA%E5%9D%80-x2F-%E7%95%8C%E9%99%90"><span class="toc-number">1.14.1.</span> <span class="toc-text">分段:泛化的基址&#x2F;界限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%91%E4%BB%AC%E5%BC%95%E5%85%A5%E5%93%AA%E4%B8%AA%E6%AE%B5"><span class="toc-number">1.14.2.</span> <span class="toc-text">我们引入哪个段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">1.14.3.</span> <span class="toc-text">栈怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E5%85%B1%E4%BA%AB"><span class="toc-number">1.14.4.</span> <span class="toc-text">支持共享</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%86%E7%B2%92%E5%BA%A6%E4%B8%8E%E7%B2%97%E7%B2%92%E5%BA%A6%E7%9A%84%E5%88%86%E6%AE%B5"><span class="toc-number">1.14.5.</span> <span class="toc-text">细粒度与粗粒度的分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%94%AF%E6%8C%81"><span class="toc-number">1.14.6.</span> <span class="toc-text">操作系统支持</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A9%BA%E9%97%B2%E7%A9%BA%E9%97%B4%E7%AE%A1%E7%90%86"><span class="toc-number">1.15.</span> <span class="toc-text">空闲空间管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%87%E8%AE%BE-1"><span class="toc-number">1.15.1.</span> <span class="toc-text">假设</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">1.15.2.</span> <span class="toc-text">底层机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%89%B2%E4%B8%8E%E5%90%88%E5%B9%B6"><span class="toc-number">1.15.2.1.</span> <span class="toc-text">分割与合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%BD%E8%B8%AA%E5%B7%B2%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.15.2.2.</span> <span class="toc-text">追踪已分配空间的大小</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E7%A9%BA%E9%97%B2%E9%98%9F%E5%88%97"><span class="toc-number">1.15.2.3.</span> <span class="toc-text">嵌入空闲队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A9%E5%A0%86%E5%A2%9E%E9%95%BF"><span class="toc-number">1.15.2.4.</span> <span class="toc-text">让堆增长</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%AD%96%E7%95%A5"><span class="toc-number">1.15.3.</span> <span class="toc-text">基本策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E5%8C%B9%E9%85%8D"><span class="toc-number">1.15.3.1.</span> <span class="toc-text">最优匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B7%AE%E5%8C%B9%E9%85%8D"><span class="toc-number">1.15.3.2.</span> <span class="toc-text">最差匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A6%96%E6%AC%A1%E5%8C%B9%E9%85%8D"><span class="toc-number">1.15.3.3.</span> <span class="toc-text">首次匹配</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8B%E6%AC%A1%E5%8C%B9%E9%85%8D"><span class="toc-number">1.15.3.4.</span> <span class="toc-text">下次匹配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.15.4.</span> <span class="toc-text">其他方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E7%A6%BB%E7%A9%BA%E9%97%B2%E5%88%97%E8%A1%A8"><span class="toc-number">1.15.4.1.</span> <span class="toc-text">分离空闲列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.16.</span> <span class="toc-text">分页:介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">1.16.1.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E8%A1%A8%E5%AD%98%E5%9C%A8%E5%93%AA"><span class="toc-number">1.16.2.</span> <span class="toc-text">页表存在哪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E4%B8%AD%E7%A9%B6%E7%AB%9F%E6%9C%89%E4%BB%80%E4%B9%88"><span class="toc-number">1.16.3.</span> <span class="toc-text">列表中究竟有什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E9%A1%B5-%E4%B9%9F%E5%BE%88%E6%85%A2"><span class="toc-number">1.16.4.</span> <span class="toc-text">分页:也很慢</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%BF%BD%E8%B8%AA"><span class="toc-number">1.16.5.</span> <span class="toc-text">内存追踪</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5-%E5%BF%AB%E9%80%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2-TLB"><span class="toc-number">1.17.</span> <span class="toc-text">分页:快速地址转换(TLB)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="toc-number">1.17.1.</span> <span class="toc-text">TLB的基本算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-%E8%AE%BF%E9%97%AE%E6%95%B0%E7%BB%84"><span class="toc-number">1.17.2.</span> <span class="toc-text">示例:访问数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%81%E6%9D%A5%E5%A4%84%E7%90%86TLB%E6%9C%AA%E5%91%BD%E4%B8%AD"><span class="toc-number">1.17.3.</span> <span class="toc-text">谁来处理TLB未命中</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.17.4.</span> <span class="toc-text">TLB的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%97%B6%E5%AF%B9TLB%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">1.17.5.</span> <span class="toc-text">上下文切换时对TLB的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.17.6.</span> <span class="toc-text">TLB替换策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%B3%BB%E7%BB%9F%E7%9A%84TLB%E8%A1%A8%E9%A1%B9"><span class="toc-number">1.17.7.</span> <span class="toc-text">实际系统的TLB表项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%A1%B5-%E8%BE%83%E5%B0%8F%E7%9A%84%E8%A1%A8"><span class="toc-number">1.18.</span> <span class="toc-text">分页:较小的表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E6%9B%B4%E5%A4%A7%E7%9A%84%E9%A1%B5"><span class="toc-number">1.18.1.</span> <span class="toc-text">简单的解决方案:更大的页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%96%B9%E6%B3%95-%E5%88%86%E9%A1%B5%E5%92%8C%E5%88%86%E6%AE%B5"><span class="toc-number">1.18.2.</span> <span class="toc-text">混合方法:分页和分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.18.3.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%90%91%E9%A1%B5%E8%A1%A8"><span class="toc-number">1.18.4.</span> <span class="toc-text">反向页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%86%E9%A1%B5%E8%A1%A8%E4%BA%A4%E6%8D%A2%E5%88%B0%E7%A3%81%E7%9B%98"><span class="toc-number">1.18.5.</span> <span class="toc-text">将页表交换到磁盘</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.19.</span> <span class="toc-text">超越物理内存:机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="toc-number">1.19.1.</span> <span class="toc-text">交换空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E4%BD%8D"><span class="toc-number">1.19.2.</span> <span class="toc-text">存在位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%94%99%E8%AF%AF"><span class="toc-number">1.19.3.</span> <span class="toc-text">页错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%BB%A1%E4%BA%86%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">1.19.4.</span> <span class="toc-text">内存满了怎么办</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B"><span class="toc-number">1.19.5.</span> <span class="toc-text">页错误处理流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E4%BD%95%E6%97%B6%E5%8F%91%E7%94%9F"><span class="toc-number">1.19.6.</span> <span class="toc-text">交换何时发生</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E8%B6%8A%E7%89%A9%E7%90%86%E5%86%85%E5%AD%98-%E7%AD%96%E7%95%A5"><span class="toc-number">1.20.</span> <span class="toc-text">超越物理内存:策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">1.20.1.</span> <span class="toc-text">缓存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E6%9B%BF%E6%8D%A2%E7%AD%96%E7%95%A5"><span class="toc-number">1.20.2.</span> <span class="toc-text">最优替换策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%AD%96%E7%95%A5-FIFO"><span class="toc-number">1.20.3.</span> <span class="toc-text">简单策略:FIFO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%E4%B8%80%E7%AE%80%E5%8D%95%E7%AD%96%E7%95%A5-%E9%9A%8F%E6%9C%BA"><span class="toc-number">1.20.4.</span> <span class="toc-text">另一简单策略:随机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%86%E5%8F%B2%E6%95%B0%E6%8D%AE-LRU"><span class="toc-number">1.20.5.</span> <span class="toc-text">利用历史数据:LRU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E7%AE%97%E6%B3%95"><span class="toc-number">1.20.6.</span> <span class="toc-text">时钟算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%8F%E9%A1%B5"><span class="toc-number">1.20.7.</span> <span class="toc-text">脏页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%96%E5%8A%A8"><span class="toc-number">1.20.8.</span> <span class="toc-text">抖动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93-4"><span class="toc-number">1.20.9.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VAX-x2F-VMS%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.21.</span> <span class="toc-text">VAX&#x2F;VMS虚拟内存系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E7%A1%AC%E4%BB%B6"><span class="toc-number">1.21.1.</span> <span class="toc-text">内存管理硬件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%9C%9F%E5%AE%9E%E7%9A%84%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">1.21.2.</span> <span class="toc-text">一个真实的地址空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E6%9B%BF%E6%8D%A2"><span class="toc-number">1.21.3.</span> <span class="toc-text">页替换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E9%9C%80%E7%BD%AE%E9%9B%B6%E5%92%8C%E5%86%99%E5%85%A5%E6%97%B6%E5%A4%8D%E5%88%B6"><span class="toc-number">1.21.4.</span> <span class="toc-text">按需置零和写入时复制</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/03/OS-thread/" title="OS-thread">OS-thread</a><time datetime="2023-08-03T11:26:02.000Z" title="发表于 2023-08-03 19:26:02">2023-08-03</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/25/stm32-study/" title="stm32-study">stm32-study</a><time datetime="2023-07-25T10:44:02.000Z" title="发表于 2023-07-25 18:44:02">2023-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/18/OSBlog/" title="OSBlog">OSBlog</a><time datetime="2023-07-18T07:57:45.000Z" title="发表于 2023-07-18 15:57:45">2023-07-18</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/14/OS/" title="OS">OS</a><time datetime="2023-07-14T07:26:36.000Z" title="发表于 2023-07-14 15:26:36">2023-07-14</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/13/STL/" title="STL">STL</a><time datetime="2023-07-13T12:54:43.000Z" title="发表于 2023-07-13 20:54:43">2023-07-13</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By guesscyj</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>